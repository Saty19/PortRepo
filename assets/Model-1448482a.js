import{r as n,u as Re,c as We,a as se,V as z,_ as ie,D as Te,O as ae,P as ce,b as _,G as B,d as De,M as G,j as y}from"./index-9cc23665.js";const W=new z,Z=new z,Oe=new z;function $e(e,t,r){const o=W.setFromMatrixPosition(e.matrixWorld);o.project(t);const s=r.width/2,a=r.height/2;return[o.x*s+s,-(o.y*a)+a]}function Fe(e,t){const r=W.setFromMatrixPosition(e.matrixWorld),o=Z.setFromMatrixPosition(t.matrixWorld),s=r.sub(o),a=t.getWorldDirection(Oe);return s.angleTo(a)>Math.PI/2}function He(e,t,r,o){const s=W.setFromMatrixPosition(e.matrixWorld),a=s.clone();a.project(t),r.setFromCamera(a,t);const c=r.intersectObjects(o,!0);if(c.length){const m=c[0].distance;return s.distanceTo(r.ray.origin)<m}return!0}function Le(e,t){if(t instanceof ae)return t.zoom;if(t instanceof ce){const r=W.setFromMatrixPosition(e.matrixWorld),o=Z.setFromMatrixPosition(t.matrixWorld),s=t.fov*Math.PI/180,a=r.distanceTo(o);return 1/(2*Math.tan(s/2)*a)}else return 1}function ze(e,t,r){if(t instanceof ce||t instanceof ae){const o=W.setFromMatrixPosition(e.matrixWorld),s=Z.setFromMatrixPosition(t.matrixWorld),a=o.distanceTo(s),c=(r[1]-r[0])/(t.far-t.near),m=r[1]-c*t.far;return Math.round(c*a+m)}}const N=e=>Math.abs(e)<1e-10?0:e;function le(e,t,r=""){let o="matrix3d(";for(let s=0;s!==16;s++)o+=N(t[s]*e.elements[s])+(s!==15?",":")");return r+o}const Ae=(e=>t=>le(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Ve=(e=>(t,r)=>le(t,e(r),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Ie(e){return e&&typeof e=="object"&&"current"in e}const ke=n.forwardRef(({children:e,eps:t=.001,style:r,className:o,prepend:s,center:a,fullscreen:c,portal:m,distanceFactor:C,sprite:he=!1,transform:g=!1,occlude:l,onOcclude:q,castShadow:fe,receiveShadow:me,material:xe,geometry:J,zIndexRange:D=[16777271,0],calculatePosition:K=$e,as:ye="div",wrapperClass:A,pointerEvents:Q="auto",...p},U)=>{const{gl:X,camera:u,scene:Y,size:h,raycaster:ge,events:pe,viewport:ve}=Re(),[d]=n.useState(()=>document.createElement(ye)),V=n.useRef(),x=n.useRef(null),ee=n.useRef(0),O=n.useRef([0,0]),E=n.useRef(null),I=n.useRef(null),S=(m==null?void 0:m.current)||pe.connected||X.domElement.parentNode,M=n.useRef(null),$=n.useRef(!1),F=n.useMemo(()=>l&&l!=="blending"||Array.isArray(l)&&l.length&&Ie(l[0]),[l]);n.useLayoutEffect(()=>{const f=X.domElement;l&&l==="blending"?(f.style.zIndex=`${Math.floor(D[0]/2)}`,f.style.position="absolute",f.style.pointerEvents="none"):(f.style.zIndex=null,f.style.position=null,f.style.pointerEvents=null)},[l]),n.useLayoutEffect(()=>{if(x.current){const f=V.current=We(d);if(Y.updateMatrixWorld(),g)d.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const i=K(x.current,u,h);d.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${i[0]}px,${i[1]}px,0);transform-origin:0 0;`}return S&&(s?S.prepend(d):S.appendChild(d)),()=>{S&&S.removeChild(d),f.unmount()}}},[S,g]),n.useLayoutEffect(()=>{A&&(d.className=A)},[A]);const te=n.useMemo(()=>g?{position:"absolute",top:0,left:0,width:h.width,height:h.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:a?"translate3d(-50%,-50%,0)":"none",...c&&{top:-h.height/2,left:-h.width/2,width:h.width,height:h.height},...r},[r,a,c,h,g]),Me=n.useMemo(()=>({position:"absolute",pointerEvents:Q}),[Q]);n.useLayoutEffect(()=>{if($.current=!1,g){var f;(f=V.current)==null||f.render(n.createElement("div",{ref:E,style:te},n.createElement("div",{ref:I,style:Me},n.createElement("div",{ref:U,className:o,style:r,children:e}))))}else{var i;(i=V.current)==null||i.render(n.createElement("div",{ref:U,style:te,className:o,children:e}))}});const j=n.useRef(!0);se(f=>{if(x.current){u.updateMatrixWorld(),x.current.updateWorldMatrix(!0,!1);const i=g?O.current:K(x.current,u,h);if(g||Math.abs(ee.current-u.zoom)>t||Math.abs(O.current[0]-i[0])>t||Math.abs(O.current[1]-i[1])>t){const P=Fe(x.current,u);let v=!1;F&&(Array.isArray(l)?v=l.map(b=>b.current):l!=="blending"&&(v=[Y]));const R=j.current;if(v){const b=He(x.current,u,ge,v);j.current=b&&!P}else j.current=!P;R!==j.current&&(q?q(!j.current):d.style.display=j.current?"block":"none");const H=Math.floor(D[0]/2),Pe=l?F?[D[0],H]:[H-1,0]:D;if(d.style.zIndex=`${ze(x.current,u,Pe)}`,g){const[b,ne]=[h.width/2,h.height/2],k=u.projectionMatrix.elements[5]*ne,{isOrthographicCamera:oe,top:be,left:we,bottom:Se,right:je}=u,Ce=Ae(u.matrixWorldInverse),Ee=oe?`scale(${k})translate(${N(-(je+we)/2)}px,${N((be+Se)/2)}px)`:`translateZ(${k}px)`;let w=x.current.matrixWorld;he&&(w=u.matrixWorldInverse.clone().transpose().copyPosition(w).scale(x.current.scale),w.elements[3]=w.elements[7]=w.elements[11]=0,w.elements[15]=1),d.style.width=h.width+"px",d.style.height=h.height+"px",d.style.perspective=oe?"":`${k}px`,E.current&&I.current&&(E.current.style.transform=`${Ee}${Ce}translate(${b}px,${ne}px)`,I.current.style.transform=Ve(w,1/((C||10)/400)))}else{const b=C===void 0?1:Le(x.current,u)*C;d.style.transform=`translate3d(${i[0]}px,${i[1]}px,0) scale(${b})`}O.current=i,ee.current=u.zoom}}if(!F&&M.current&&!$.current)if(g){if(E.current){const i=E.current.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const{isOrthographicCamera:P}=u;if(P||J)p.scale&&(Array.isArray(p.scale)?p.scale instanceof z?M.current.scale.copy(p.scale.clone().divideScalar(1)):M.current.scale.set(1/p.scale[0],1/p.scale[1],1/p.scale[2]):M.current.scale.setScalar(1/p.scale));else{const v=(C||10)/400,R=i.clientWidth*v,H=i.clientHeight*v;M.current.scale.set(R,H,1)}$.current=!0}}}else{const i=d.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const P=1/ve.factor,v=i.clientWidth*P,R=i.clientHeight*P;M.current.scale.set(v,R,1),$.current=!0}M.current.lookAt(f.camera.position)}});const re=n.useMemo(()=>({vertexShader:g?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[g]);return n.createElement("group",ie({},p,{ref:x}),l&&!F&&n.createElement("mesh",{castShadow:fe,receiveShadow:me,ref:M},J||n.createElement("planeGeometry",null),xe||n.createElement("shaderMaterial",{side:Te,vertexShader:re.vertexShader,fragmentShader:re.fragmentShader})))});let L=null,ue="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function de(e,t,r){return o=>{r&&r(o),e&&(L||(L=new De),L.setDecoderPath(typeof e=="string"?e:ue),o.setDRACOLoader(L)),t&&o.setMeshoptDecoder(typeof G=="function"?G():G)}}function T(e,t=!0,r=!0,o){return _(B,e,de(t,r,o))}T.preload=(e,t=!0,r=!0,o)=>_.preload(B,e,de(t,r,o));T.clear=e=>_.clear(B,e);T.setDecoderPath=e=>{ue=e};function Ge(e,t){const r=e+"Geometry";return n.forwardRef(({args:o,children:s,...a},c)=>{const m=n.useRef(null);return n.useImperativeHandle(c,()=>m.current),n.useLayoutEffect(()=>void(t==null?void 0:t(m.current))),n.createElement("mesh",ie({ref:m},a),n.createElement(r,{attach:"geometry",args:o}),s)})}const Ne=Ge("plane"),_e="_htmlMain_1lssb_1",Be={htmlMain:_e};function qe(e){const{nodes:t,materials:r}=T("./TEST.glb"),o=n.useRef(),s=n.useRef(),a=n.useRef(),c=e.Hovered;return se(()=>{s.current.rotation.y+=.01,a.current.rotation.y+=-.01}),y.jsx("group",{...e,dispose:null,ref:o,children:y.jsxs("group",{scale:[8,8,8],"rotation-x":-25.5,"rotation-y":26.2,"rotation-z":45,children:[y.jsx("group",{ref:s,children:y.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Circle.geometry,material:r["Material.005"],rotation:[0,-1.4,0],scale:1.1,userData:{name:"Circle"}})}),y.jsx("group",{ref:a,children:y.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Circle001.geometry,material:r["Material.006"],position:[0,.1,0],scale:[.9,1.1,.9],userData:{name:"Circle.001"}})}),y.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Circle002.geometry,material:r["Material.007"],position:[0,.3,0],scale:.4,userData:{name:"Circle.002"}}),y.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Circle003.geometry,material:r["Material.008"],position:[0,.2,0],scale:.7,userData:{name:"Circle.003"}}),y.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Circle004.geometry,material:r["Material.009"],position:[0,.3,0],scale:.2,userData:{name:"Circle.004"},children:y.jsx(Ne,{visible:!1,"rotation-y":-70,scale:[10,10,1],position:[0,2,-1],children:y.jsx(ke,{className:Be.htmlMain,"rotation-x":-Math.PI*2,position:[1e-4,0,1],transform:!0,scale:.08,center:!0,style:{opacity:"0.8",width:"100%",height:"100%"},children:y.jsx("div",{style:{height:"100%",fontSize:"2vw"},onPointerDown:m=>m.stopPropagation(),children:c&&c.name})})})})]})})}T.preload("./TEST.glb");export{qe as default};
