import{r,u as Ee,c as Ce,a as se,_ as We,D as Re,V as L,O as ae,P as ce,j as s,b as le,M as F}from"./index-7b31e60a.js";const T=new L,q=new L,Te=new L;function Ae(e,t,n){const o=T.setFromMatrixPosition(e.matrixWorld);o.project(t);const a=n.width/2,l=n.height/2;return[o.x*a+a,-(o.y*l)+l]}function Oe(e,t){const n=T.setFromMatrixPosition(e.matrixWorld),o=q.setFromMatrixPosition(t.matrixWorld),a=n.sub(o),l=t.getWorldDirection(Te);return a.angleTo(l)>Math.PI/2}function ze(e,t,n,o){const a=T.setFromMatrixPosition(e.matrixWorld),l=a.clone();l.project(t),n.setFromCamera(l,t);const c=n.intersectObjects(o,!0);if(c.length){const M=c[0].distance;return a.distanceTo(n.ray.origin)<M}return!0}function $e(e,t){if(t instanceof ae)return t.zoom;if(t instanceof ce){const n=T.setFromMatrixPosition(e.matrixWorld),o=q.setFromMatrixPosition(t.matrixWorld),a=t.fov*Math.PI/180,l=n.distanceTo(o);return 1/(2*Math.tan(a/2)*l)}else return 1}function _e(e,t,n){if(t instanceof ce||t instanceof ae){const o=T.setFromMatrixPosition(e.matrixWorld),a=q.setFromMatrixPosition(t.matrixWorld),l=o.distanceTo(a),c=(n[1]-n[0])/(t.far-t.near),M=n[1]-c*t.far;return Math.round(c*l+M)}}const G=e=>Math.abs(e)<1e-10?0:e;function ue(e,t,n=""){let o="matrix3d(";for(let a=0;a!==16;a++)o+=G(t[a]*e.elements[a])+(a!==15?",":")");return n+o}const Fe=(e=>t=>ue(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),ke=(e=>(t,n)=>ue(t,e(n),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Le(e){return e&&typeof e=="object"&&"current"in e}const oe=r.forwardRef(({children:e,eps:t=.001,style:n,className:o,prepend:a,center:l,fullscreen:c,portal:M,distanceFactor:x,sprite:S=!1,transform:g=!1,occlude:u,onOcclude:B,castShadow:de,receiveShadow:me,material:he,geometry:U,zIndexRange:A=[16777271,0],calculatePosition:Z=Ae,as:fe="div",wrapperClass:H,pointerEvents:J="auto",...y},K)=>{const{gl:Q,camera:d,scene:X,size:h,raycaster:xe,events:pe,viewport:ge}=Ee(),[m]=r.useState(()=>document.createElement(fe)),N=r.useRef(),p=r.useRef(null),Y=r.useRef(0),O=r.useRef([0,0]),W=r.useRef(null),D=r.useRef(null),E=(M==null?void 0:M.current)||pe.connected||Q.domElement.parentNode,b=r.useRef(null),z=r.useRef(!1),$=r.useMemo(()=>u&&u!=="blending"||Array.isArray(u)&&u.length&&Le(u[0]),[u]);r.useLayoutEffect(()=>{const f=Q.domElement;u&&u==="blending"?(f.style.zIndex=`${Math.floor(A[0]/2)}`,f.style.position="absolute",f.style.pointerEvents="none"):(f.style.zIndex=null,f.style.position=null,f.style.pointerEvents=null)},[u]),r.useLayoutEffect(()=>{if(p.current){const f=N.current=Ce(m);if(X.updateMatrixWorld(),g)m.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const i=Z(p.current,d,h);m.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${i[0]}px,${i[1]}px,0);transform-origin:0 0;`}return E&&(a?E.prepend(m):E.appendChild(m)),()=>{E&&E.removeChild(m),f.unmount()}}},[E,g]),r.useLayoutEffect(()=>{H&&(m.className=H)},[H]);const ee=r.useMemo(()=>g?{position:"absolute",top:0,left:0,width:h.width,height:h.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:l?"translate3d(-50%,-50%,0)":"none",...c&&{top:-h.height/2,left:-h.width/2,width:h.width,height:h.height},...n},[n,l,c,h,g]),ye=r.useMemo(()=>({position:"absolute",pointerEvents:J}),[J]);r.useLayoutEffect(()=>{if(z.current=!1,g){var f;(f=N.current)==null||f.render(r.createElement("div",{ref:W,style:ee},r.createElement("div",{ref:D,style:ye},r.createElement("div",{ref:K,className:o,style:n,children:e}))))}else{var i;(i=N.current)==null||i.render(r.createElement("div",{ref:K,style:ee,className:o,children:e}))}});const C=r.useRef(!0);se(f=>{if(p.current){d.updateMatrixWorld(),p.current.updateWorldMatrix(!0,!1);const i=g?O.current:Z(p.current,d,h);if(g||Math.abs(Y.current-d.zoom)>t||Math.abs(O.current[0]-i[0])>t||Math.abs(O.current[1]-i[1])>t){const P=Oe(p.current,d);let v=!1;$&&(Array.isArray(u)?v=u.map(w=>w.current):u!=="blending"&&(v=[X]));const R=C.current;if(v){const w=ze(p.current,d,xe,v);C.current=w&&!P}else C.current=!P;R!==C.current&&(B?B(!C.current):m.style.display=C.current?"block":"none");const _=Math.floor(A[0]/2),ve=u?$?[A[0],_]:[_-1,0]:A;if(m.style.zIndex=`${_e(p.current,d,ve)}`,g){const[w,ne]=[h.width/2,h.height/2],V=d.projectionMatrix.elements[5]*ne,{isOrthographicCamera:re,top:Me,left:be,bottom:Pe,right:we}=d,je=Fe(d.matrixWorldInverse),Se=re?`scale(${V})translate(${G(-(we+be)/2)}px,${G((Me+Pe)/2)}px)`:`translateZ(${V}px)`;let j=p.current.matrixWorld;S&&(j=d.matrixWorldInverse.clone().transpose().copyPosition(j).scale(p.current.scale),j.elements[3]=j.elements[7]=j.elements[11]=0,j.elements[15]=1),m.style.width=h.width+"px",m.style.height=h.height+"px",m.style.perspective=re?"":`${V}px`,W.current&&D.current&&(W.current.style.transform=`${Se}${je}translate(${w}px,${ne}px)`,D.current.style.transform=ke(j,1/((x||10)/400)))}else{const w=x===void 0?1:$e(p.current,d)*x;m.style.transform=`translate3d(${i[0]}px,${i[1]}px,0) scale(${w})`}O.current=i,Y.current=d.zoom}}if(!$&&b.current&&!z.current)if(g){if(W.current){const i=W.current.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const{isOrthographicCamera:P}=d;if(P||U)y.scale&&(Array.isArray(y.scale)?y.scale instanceof L?b.current.scale.copy(y.scale.clone().divideScalar(1)):b.current.scale.set(1/y.scale[0],1/y.scale[1],1/y.scale[2]):b.current.scale.setScalar(1/y.scale));else{const v=(x||10)/400,R=i.clientWidth*v,_=i.clientHeight*v;b.current.scale.set(R,_,1)}z.current=!0}}}else{const i=m.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const P=1/ge.factor,v=i.clientWidth*P,R=i.clientHeight*P;b.current.scale.set(v,R,1),z.current=!0}b.current.lookAt(f.camera.position)}});const te=r.useMemo(()=>({vertexShader:g?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[g]);return r.createElement("group",We({},y,{ref:p}),u&&!$&&r.createElement("mesh",{castShadow:de,receiveShadow:me,ref:b},U||r.createElement("planeGeometry",null),he||r.createElement("shaderMaterial",{side:Re,vertexShader:te.vertexShader,fragmentShader:te.fragmentShader})))}),He="_content_1y4nm_2",Ne="_wrapper_1y4nm_13",De="_drag_1y4nm_22",I={content:He,wrapper:Ne,drag:De},k=()=>{const e={height:"100vh",width:"190%",backgroundColor:"#f0f0f0",textAlign:"center"},t={maxWidth:"100%",maxHeight:"400px",margin:"20px 0",borderRadius:"8px"};return s.jsxs("div",{style:e,children:[s.jsx("h1",{children:"Tall Component"}),s.jsx("img",{src:"https://via.placeholder.com/800x400",alt:"Placeholder Image",style:t}),s.jsx("p",{style:{color:"black"},children:"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."})]})},Ve=()=>{const e={height:"100vh",width:"190%",padding:"10px",transform:"scale(0.5)",transformOrigin:"top left",backgroundColor:"#121212",boxShadow:"0 0 10px rgba(0, 0, 0, 0.1)",textAlign:"center"},t={color:"#333",fontSize:"24px",marginBottom:"15px"},n={color:"#666",fontSize:"16px"};return s.jsxs("div",{style:e,children:[s.jsx("h2",{style:t,children:"Simple Component"}),s.jsx("p",{style:n,children:"This is a simple React component with inline styles."})]})},ie=Ve;function Ge(e){const{nodes:t,materials:n}=le("./mac-draco.glb"),o=r.useRef();se(x=>{const S=x.clock.getElapsedTime();o.current.rotation.x=F.lerp(o.current.rotation.x,Math.cos(S/2)/20+.25,.1),o.current.rotation.y=F.lerp(o.current.rotation.y,Math.sin(S/4)/20,.1),o.current.rotation.z=F.lerp(o.current.rotation.z,Math.sin(S/8)/20,.1),o.current.position.y=F.lerp(o.current.position.y,(-2+Math.sin(S/2))/2,.1)});const l={MAGENTO:k,REACT:ie,ANGULAR:k,PHP:k,LARAVEL:k};e.Scale;const c=e==null?void 0:e.Hovered;r.useMemo(()=>l[c==null?void 0:c.name],[c==null?void 0:c.name]);const M=window.innerWidth<810?[0,.05,0]:[.35,.05,-.5];return r.useEffect(()=>{function x(){setWindowWidth(window.innerWidth)}return window.addEventListener("resize",x),()=>{window.removeEventListener("resize",x)}},[]),s.jsxs("group",{ref:o,...e,dispose:null,children:[window.innerWidth>=810&&s.jsx(oe,{distanceFactor:10,position:[5,0,5],children:s.jsx("div",{className:I.drag,children:"DRAG HERE"})}),s.jsx("group",{"rotation-x":-.425,position:[0,-.04,.41],children:s.jsxs("group",{position:[0,2.96,-.13],rotation:[Math.PI/2,0,0],children:[s.jsx("mesh",{material:n.aluminium,geometry:t.Cube008.geometry}),s.jsx("mesh",{material:n["matte.001"],geometry:t.Cube008_1.geometry}),s.jsx("mesh",{geometry:t.Cube008_2.geometry,children:s.jsx(oe,{className:I.content,"rotation-x":-Math.PI/2,position:M,transform:!0,occlude:!0,children:s.jsx("div",{className:I.wrapper,onPointerDown:x=>x.stopPropagation(),children:(c==null?void 0:c.name)==="MAGENTO"&&s.jsx(ie,{})})})})]})}),s.jsx("mesh",{material:n.keys,geometry:t.keyboard.geometry,position:[1.79,0,3.45]}),s.jsxs("group",{position:[0,-.1,3.39],children:[s.jsx("mesh",{material:n.aluminium,geometry:t.Cube002.geometry}),s.jsx("mesh",{material:n.trackpad,geometry:t.Cube002_1.geometry})]}),s.jsx("mesh",{material:n.touchbar,geometry:t.touchbar.geometry,position:[0,-.03,1.2]})]})}le.preload("./mac-draco.glb");export{Ge as default};
