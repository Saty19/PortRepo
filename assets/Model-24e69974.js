import{r as o,u as Se,c as Ee,a as ie,_ as Ce,D as We,V as _,O as se,P as ae,j as s,b as ce,M as F}from"./index-52863fba.js";const T=new _,q=new _,Re=new _;function Te(e,t,n){const r=T.setFromMatrixPosition(e.matrixWorld);r.project(t);const a=n.width/2,l=n.height/2;return[r.x*a+a,-(r.y*l)+l]}function Ae(e,t){const n=T.setFromMatrixPosition(e.matrixWorld),r=q.setFromMatrixPosition(t.matrixWorld),a=n.sub(r),l=t.getWorldDirection(Re);return a.angleTo(l)>Math.PI/2}function Oe(e,t,n,r){const a=T.setFromMatrixPosition(e.matrixWorld),l=a.clone();l.project(t),n.setFromCamera(l,t);const c=n.intersectObjects(r,!0);if(c.length){const M=c[0].distance;return a.distanceTo(n.ray.origin)<M}return!0}function ze(e,t){if(t instanceof se)return t.zoom;if(t instanceof ae){const n=T.setFromMatrixPosition(e.matrixWorld),r=q.setFromMatrixPosition(t.matrixWorld),a=t.fov*Math.PI/180,l=n.distanceTo(r);return 1/(2*Math.tan(a/2)*l)}else return 1}function $e(e,t,n){if(t instanceof ae||t instanceof se){const r=T.setFromMatrixPosition(e.matrixWorld),a=q.setFromMatrixPosition(t.matrixWorld),l=r.distanceTo(a),c=(n[1]-n[0])/(t.far-t.near),M=n[1]-c*t.far;return Math.round(c*l+M)}}const I=e=>Math.abs(e)<1e-10?0:e;function le(e,t,n=""){let r="matrix3d(";for(let a=0;a!==16;a++)r+=I(t[a]*e.elements[a])+(a!==15?",":")");return n+r}const ke=(e=>t=>le(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Fe=(e=>(t,n)=>le(t,e(n),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Le(e){return e&&typeof e=="object"&&"current"in e}const _e=o.forwardRef(({children:e,eps:t=.001,style:n,className:r,prepend:a,center:l,fullscreen:c,portal:M,distanceFactor:x,sprite:S=!1,transform:g=!1,occlude:u,onOcclude:G,castShadow:ue,receiveShadow:me,material:de,geometry:B,zIndexRange:A=[16777271,0],calculatePosition:U=Te,as:he="div",wrapperClass:H,pointerEvents:Z="auto",...y},J)=>{const{gl:K,camera:m,scene:Q,size:h,raycaster:fe,events:xe,viewport:pe}=Se(),[d]=o.useState(()=>document.createElement(he)),N=o.useRef(),p=o.useRef(null),X=o.useRef(0),O=o.useRef([0,0]),W=o.useRef(null),V=o.useRef(null),E=(M==null?void 0:M.current)||xe.connected||K.domElement.parentNode,b=o.useRef(null),z=o.useRef(!1),$=o.useMemo(()=>u&&u!=="blending"||Array.isArray(u)&&u.length&&Le(u[0]),[u]);o.useLayoutEffect(()=>{const f=K.domElement;u&&u==="blending"?(f.style.zIndex=`${Math.floor(A[0]/2)}`,f.style.position="absolute",f.style.pointerEvents="none"):(f.style.zIndex=null,f.style.position=null,f.style.pointerEvents=null)},[u]),o.useLayoutEffect(()=>{if(p.current){const f=N.current=Ee(d);if(Q.updateMatrixWorld(),g)d.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const i=U(p.current,m,h);d.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${i[0]}px,${i[1]}px,0);transform-origin:0 0;`}return E&&(a?E.prepend(d):E.appendChild(d)),()=>{E&&E.removeChild(d),f.unmount()}}},[E,g]),o.useLayoutEffect(()=>{H&&(d.className=H)},[H]);const Y=o.useMemo(()=>g?{position:"absolute",top:0,left:0,width:h.width,height:h.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:l?"translate3d(-50%,-50%,0)":"none",...c&&{top:-h.height/2,left:-h.width/2,width:h.width,height:h.height},...n},[n,l,c,h,g]),ge=o.useMemo(()=>({position:"absolute",pointerEvents:Z}),[Z]);o.useLayoutEffect(()=>{if(z.current=!1,g){var f;(f=N.current)==null||f.render(o.createElement("div",{ref:W,style:Y},o.createElement("div",{ref:V,style:ge},o.createElement("div",{ref:J,className:r,style:n,children:e}))))}else{var i;(i=N.current)==null||i.render(o.createElement("div",{ref:J,style:Y,className:r,children:e}))}});const C=o.useRef(!0);ie(f=>{if(p.current){m.updateMatrixWorld(),p.current.updateWorldMatrix(!0,!1);const i=g?O.current:U(p.current,m,h);if(g||Math.abs(X.current-m.zoom)>t||Math.abs(O.current[0]-i[0])>t||Math.abs(O.current[1]-i[1])>t){const P=Ae(p.current,m);let v=!1;$&&(Array.isArray(u)?v=u.map(w=>w.current):u!=="blending"&&(v=[Q]));const R=C.current;if(v){const w=Oe(p.current,m,fe,v);C.current=w&&!P}else C.current=!P;R!==C.current&&(G?G(!C.current):d.style.display=C.current?"block":"none");const k=Math.floor(A[0]/2),ye=u?$?[A[0],k]:[k-1,0]:A;if(d.style.zIndex=`${$e(p.current,m,ye)}`,g){const[w,te]=[h.width/2,h.height/2],D=m.projectionMatrix.elements[5]*te,{isOrthographicCamera:ne,top:ve,left:Me,bottom:be,right:Pe}=m,we=ke(m.matrixWorldInverse),je=ne?`scale(${D})translate(${I(-(Pe+Me)/2)}px,${I((ve+be)/2)}px)`:`translateZ(${D}px)`;let j=p.current.matrixWorld;S&&(j=m.matrixWorldInverse.clone().transpose().copyPosition(j).scale(p.current.scale),j.elements[3]=j.elements[7]=j.elements[11]=0,j.elements[15]=1),d.style.width=h.width+"px",d.style.height=h.height+"px",d.style.perspective=ne?"":`${D}px`,W.current&&V.current&&(W.current.style.transform=`${je}${we}translate(${w}px,${te}px)`,V.current.style.transform=Fe(j,1/((x||10)/400)))}else{const w=x===void 0?1:ze(p.current,m)*x;d.style.transform=`translate3d(${i[0]}px,${i[1]}px,0) scale(${w})`}O.current=i,X.current=m.zoom}}if(!$&&b.current&&!z.current)if(g){if(W.current){const i=W.current.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const{isOrthographicCamera:P}=m;if(P||B)y.scale&&(Array.isArray(y.scale)?y.scale instanceof _?b.current.scale.copy(y.scale.clone().divideScalar(1)):b.current.scale.set(1/y.scale[0],1/y.scale[1],1/y.scale[2]):b.current.scale.setScalar(1/y.scale));else{const v=(x||10)/400,R=i.clientWidth*v,k=i.clientHeight*v;b.current.scale.set(R,k,1)}z.current=!0}}}else{const i=d.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const P=1/pe.factor,v=i.clientWidth*P,R=i.clientHeight*P;b.current.scale.set(v,R,1),z.current=!0}b.current.lookAt(f.camera.position)}});const ee=o.useMemo(()=>({vertexShader:g?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[g]);return o.createElement("group",Ce({},y,{ref:p}),u&&!$&&o.createElement("mesh",{castShadow:ue,receiveShadow:me,ref:b},B||o.createElement("planeGeometry",null),de||o.createElement("shaderMaterial",{side:We,vertexShader:ee.vertexShader,fragmentShader:ee.fragmentShader})))}),He="_content_17mq6_2",Ne="_wrapper_17mq6_13",oe={content:He,wrapper:Ne},L=()=>{const e={height:"100vh",width:"190%",backgroundColor:"#f0f0f0",textAlign:"center"},t={maxWidth:"100%",maxHeight:"400px",margin:"20px 0",borderRadius:"8px"};return s.jsxs("div",{style:e,children:[s.jsx("h1",{children:"Tall Component"}),s.jsx("img",{src:"https://via.placeholder.com/800x400",alt:"Placeholder Image",style:t}),s.jsx("p",{style:{color:"black"},children:"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."})]})},Ve=()=>{const e={height:"100vh",width:"190%",padding:"10px",transform:"scale(0.5)",transformOrigin:"top left",backgroundColor:"#121212",boxShadow:"0 0 10px rgba(0, 0, 0, 0.1)",textAlign:"center"},t={color:"#333",fontSize:"24px",marginBottom:"15px"},n={color:"#666",fontSize:"16px"};return s.jsxs("div",{style:e,children:[s.jsx("h2",{style:t,children:"Simple Component"}),s.jsx("p",{style:n,children:"This is a simple React component with inline styles."})]})},re=Ve;function Ie(e){const{nodes:t,materials:n}=ce("./mac-draco.glb"),r=o.useRef();ie(x=>{const S=x.clock.getElapsedTime();r.current.rotation.x=F.lerp(r.current.rotation.x,Math.cos(S/2)/20+.25,.1),r.current.rotation.y=F.lerp(r.current.rotation.y,Math.sin(S/4)/20,.1),r.current.rotation.z=F.lerp(r.current.rotation.z,Math.sin(S/8)/20,.1),r.current.position.y=F.lerp(r.current.position.y,(-2+Math.sin(S/2))/2,.1)});const l={MAGENTO:L,REACT:re,ANGULAR:L,PHP:L,LARAVEL:L};e.Scale;const c=e==null?void 0:e.Hovered;o.useMemo(()=>l[c==null?void 0:c.name],[c==null?void 0:c.name]);const M=window.innerWidth<810?[0,.05,0]:[.35,.05,-.5];return o.useEffect(()=>{function x(){setWindowWidth(window.innerWidth)}return window.addEventListener("resize",x),()=>{window.removeEventListener("resize",x)}},[]),s.jsxs("group",{ref:r,...e,dispose:null,children:[s.jsx("group",{"rotation-x":-.425,position:[0,-.04,.41],children:s.jsxs("group",{position:[0,2.96,-.13],rotation:[Math.PI/2,0,0],children:[s.jsx("mesh",{material:n.aluminium,geometry:t.Cube008.geometry}),s.jsx("mesh",{material:n["matte.001"],geometry:t.Cube008_1.geometry}),s.jsx("mesh",{geometry:t.Cube008_2.geometry,children:s.jsx(_e,{className:oe.content,"rotation-x":-Math.PI/2,position:M,transform:!0,occlude:!0,children:s.jsx("div",{className:oe.wrapper,onPointerDown:x=>x.stopPropagation(),children:(c==null?void 0:c.name)==="MAGENTO"&&s.jsx(re,{})})})})]})}),s.jsx("mesh",{material:n.keys,geometry:t.keyboard.geometry,position:[1.79,0,3.45]}),s.jsxs("group",{position:[0,-.1,3.39],children:[s.jsx("mesh",{material:n.aluminium,geometry:t.Cube002.geometry}),s.jsx("mesh",{material:n.trackpad,geometry:t.Cube002_1.geometry})]}),s.jsx("mesh",{material:n.touchbar,geometry:t.touchbar.geometry,position:[0,-.03,1.2]})]})}ce.preload("./mac-draco.glb");export{Ie as default};
