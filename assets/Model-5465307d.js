import{a4 as s,a7 as je,au as Ce,a9 as Be,k as D,av as Te,e as ke,ah as ae,P as ne,ad as G,aw as N,ax as Ee,ay as I,a5 as i,az as We}from"./index-75325bc1.js";const T=new D,Z=new D,Re=new D;function Oe(t,e,r){const o=T.setFromMatrixPosition(t.matrixWorld);o.project(e);const n=r.width/2,c=r.height/2;return[o.x*n+n,-(o.y*c)+c]}function $e(t,e){const r=T.setFromMatrixPosition(t.matrixWorld),o=Z.setFromMatrixPosition(e.matrixWorld),n=r.sub(o),c=e.getWorldDirection(Re);return n.angleTo(c)>Math.PI/2}function Fe(t,e,r,o){const n=T.setFromMatrixPosition(t.matrixWorld),c=n.clone();c.project(e),r.setFromCamera(c,e);const y=r.intersectObjects(o,!0);if(y.length){const b=y[0].distance;return n.distanceTo(r.ray.origin)<b}return!0}function De(t,e){if(e instanceof ae)return e.zoom;if(e instanceof ne){const r=T.setFromMatrixPosition(t.matrixWorld),o=Z.setFromMatrixPosition(e.matrixWorld),n=e.fov*Math.PI/180,c=r.distanceTo(o);return 1/(2*Math.tan(n/2)*c)}else return 1}function Le(t,e,r){if(e instanceof ne||e instanceof ae){const o=T.setFromMatrixPosition(t.matrixWorld),n=Z.setFromMatrixPosition(e.matrixWorld),c=o.distanceTo(n),y=(r[1]-r[0])/(e.far-e.near),b=r[1]-y*e.far;return Math.round(y*c+b)}}const V=t=>Math.abs(t)<1e-10?0:t;function ie(t,e,r=""){let o="matrix3d(";for(let n=0;n!==16;n++)o+=V(e[n]*t.elements[n])+(n!==15?",":")");return r+o}const Ae=(t=>e=>ie(e,t))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),ze=(t=>(e,r)=>ie(e,t(r),"translate(-50%,-50%)"))(t=>[1/t,1/t,1/t,1,-1/t,-1/t,-1/t,-1,1/t,1/t,1/t,1,1,1,1,1]);function He(t){return t&&typeof t=="object"&&"current"in t}const Ie=s.forwardRef(({children:t,eps:e=.001,style:r,className:o,prepend:n,center:c,fullscreen:y,portal:b,distanceFactor:j,sprite:ue=!1,transform:x=!1,occlude:l,onOcclude:K,castShadow:me,receiveShadow:de,material:he,geometry:q,zIndexRange:E=[16777271,0],calculatePosition:J=Oe,as:fe="div",wrapperClass:L,pointerEvents:Q="auto",...g},U)=>{const{gl:X,camera:u,scene:Y,size:d,raycaster:xe,events:ye,viewport:ge}=je(),[m]=s.useState(()=>document.createElement(fe)),A=s.useRef(),f=s.useRef(null),ee=s.useRef(0),W=s.useRef([0,0]),C=s.useRef(null),z=s.useRef(null),M=(b==null?void 0:b.current)||ye.connected||X.domElement.parentNode,v=s.useRef(null),R=s.useRef(!1),O=s.useMemo(()=>l&&l!=="blending"||Array.isArray(l)&&l.length&&He(l[0]),[l]);s.useLayoutEffect(()=>{const h=X.domElement;l&&l==="blending"?(h.style.zIndex=`${Math.floor(E[0]/2)}`,h.style.position="absolute",h.style.pointerEvents="none"):(h.style.zIndex=null,h.style.position=null,h.style.pointerEvents=null)},[l]),s.useLayoutEffect(()=>{if(f.current){const h=A.current=Ce(m);if(Y.updateMatrixWorld(),x)m.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const a=J(f.current,u,d);m.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${a[0]}px,${a[1]}px,0);transform-origin:0 0;`}return M&&(n?M.prepend(m):M.appendChild(m)),()=>{M&&M.removeChild(m),h.unmount()}}},[M,x]),s.useLayoutEffect(()=>{L&&(m.className=L)},[L]);const te=s.useMemo(()=>x?{position:"absolute",top:0,left:0,width:d.width,height:d.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:c?"translate3d(-50%,-50%,0)":"none",...y&&{top:-d.height/2,left:-d.width/2,width:d.width,height:d.height},...r},[r,c,y,d,x]),pe=s.useMemo(()=>({position:"absolute",pointerEvents:Q}),[Q]);s.useLayoutEffect(()=>{if(R.current=!1,x){var h;(h=A.current)==null||h.render(s.createElement("div",{ref:C,style:te},s.createElement("div",{ref:z,style:pe},s.createElement("div",{ref:U,className:o,style:r,children:t}))))}else{var a;(a=A.current)==null||a.render(s.createElement("div",{ref:U,style:te,className:o,children:t}))}});const _=s.useRef(!0);Be(h=>{if(f.current){u.updateMatrixWorld(),f.current.updateWorldMatrix(!0,!1);const a=x?W.current:J(f.current,u,d);if(x||Math.abs(ee.current-u.zoom)>e||Math.abs(W.current[0]-a[0])>e||Math.abs(W.current[1]-a[1])>e){const w=$e(f.current,u);let p=!1;O&&(Array.isArray(l)?p=l.map(P=>P.current):l!=="blending"&&(p=[Y]));const B=_.current;if(p){const P=Fe(f.current,u,xe,p);_.current=P&&!w}else _.current=!w;B!==_.current&&(K?K(!_.current):m.style.display=_.current?"block":"none");const $=Math.floor(E[0]/2),ve=l?O?[E[0],$]:[$-1,0]:E;if(m.style.zIndex=`${Le(f.current,u,ve)}`,x){const[P,oe]=[d.width/2,d.height/2],H=u.projectionMatrix.elements[5]*oe,{isOrthographicCamera:se,top:we,left:Pe,bottom:Se,right:be}=u,Me=Ae(u.matrixWorldInverse),_e=se?`scale(${H})translate(${V(-(be+Pe)/2)}px,${V((we+Se)/2)}px)`:`translateZ(${H}px)`;let S=f.current.matrixWorld;ue&&(S=u.matrixWorldInverse.clone().transpose().copyPosition(S).scale(f.current.scale),S.elements[3]=S.elements[7]=S.elements[11]=0,S.elements[15]=1),m.style.width=d.width+"px",m.style.height=d.height+"px",m.style.perspective=se?"":`${H}px`,C.current&&z.current&&(C.current.style.transform=`${_e}${Me}translate(${P}px,${oe}px)`,z.current.style.transform=ze(S,1/((j||10)/400)))}else{const P=j===void 0?1:De(f.current,u)*j;m.style.transform=`translate3d(${a[0]}px,${a[1]}px,0) scale(${P})`}W.current=a,ee.current=u.zoom}}if(!O&&v.current&&!R.current)if(x){if(C.current){const a=C.current.children[0];if(a!=null&&a.clientWidth&&a!=null&&a.clientHeight){const{isOrthographicCamera:w}=u;if(w||q)g.scale&&(Array.isArray(g.scale)?g.scale instanceof D?v.current.scale.copy(g.scale.clone().divideScalar(1)):v.current.scale.set(1/g.scale[0],1/g.scale[1],1/g.scale[2]):v.current.scale.setScalar(1/g.scale));else{const p=(j||10)/400,B=a.clientWidth*p,$=a.clientHeight*p;v.current.scale.set(B,$,1)}R.current=!0}}}else{const a=m.children[0];if(a!=null&&a.clientWidth&&a!=null&&a.clientHeight){const w=1/ge.factor,p=a.clientWidth*w,B=a.clientHeight*w;v.current.scale.set(p,B,1),R.current=!0}v.current.lookAt(h.camera.position)}});const re=s.useMemo(()=>({vertexShader:x?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[x]);return s.createElement("group",Te({},g,{ref:f}),l&&!O&&s.createElement("mesh",{castShadow:me,receiveShadow:de,ref:v},q||s.createElement("planeGeometry",null),he||s.createElement("shaderMaterial",{side:ke,vertexShader:re.vertexShader,fragmentShader:re.fragmentShader})))});let F=null,ce="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function le(t,e,r){return o=>{r&&r(o),t&&(F||(F=new Ee),F.setDecoderPath(typeof t=="string"?t:ce),o.setDRACOLoader(F)),e&&o.setMeshoptDecoder(typeof I=="function"?I():I)}}function k(t,e=!0,r=!0,o){return G(N,t,le(e,r,o))}k.preload=(t,e=!0,r=!0,o)=>G.preload(N,t,le(e,r,o));k.clear=t=>G.clear(N,t);k.setDecoderPath=t=>{ce=t};const Ve="_htmlMain_1lssb_1",Ge={htmlMain:Ve};function Ze(t){const{nodes:e,materials:r}=k("/laptop.glb"),o=t.Hovered;return i.jsxs("group",{...t,dispose:null,scale:[2,2,2],children:[i.jsxs("group",{rotation:[-Math.PI,0,-3.135],children:[i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001.geometry,material:r["Black.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_1.geometry,material:r["Main.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_2.geometry,material:r["Second.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_3.geometry,material:r["KeysMain.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_4.geometry,material:r["KeysBottom.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_5.geometry,material:r["TopLine.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_6.geometry,material:r["DarkGrey.001"]})]}),i.jsxs("group",{rotation:[-Math.PI,0,-3.135],children:[i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001.geometry,material:r["Outline.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_1.geometry,material:r["Screen.001"],children:i.jsx(Ie,{className:Ge.htmlMain,position:[0,1,-.1],transform:!0,occlude:!0,"rotation-y":91.1,scale:.07,center:!0,style:{opacity:"0.8",width:"1920px",height:"1100px"},children:i.jsx("div",{style:{height:"100%",fontSize:"2vw"},onPointerDown:n=>n.stopPropagation(),children:(o==null?void 0:o.name)==="MAGENTO"&&i.jsx(We,{})})})}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_2.geometry,material:r["Emission.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_3.geometry,material:r["Logo.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_4.geometry,material:r["Main.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_5.geometry,material:r["Text.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_6.geometry,material:r["Camera.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_7.geometry,material:r["Camera1.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_8.geometry,material:r["CameraGreen.001"]})]})]})}k.preload("/laptop.glb");export{Ze as default};
