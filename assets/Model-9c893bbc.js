import{r as n,u as Re,c as We,a as Ce,_ as oe,D as Oe,V as A,O as ie,P as ae,b as N,G as B,d as Te,M as k,j as y}from"./index-7222c606.js";const C=new A,Z=new A,$e=new A;function Fe(e,t,r){const s=C.setFromMatrixPosition(e.matrixWorld);s.project(t);const i=r.width/2,a=r.height/2;return[s.x*i+i,-(s.y*a)+a]}function He(e,t){const r=C.setFromMatrixPosition(e.matrixWorld),s=Z.setFromMatrixPosition(t.matrixWorld),i=r.sub(s),a=t.getWorldDirection($e);return i.angleTo(a)>Math.PI/2}function De(e,t,r,s){const i=C.setFromMatrixPosition(e.matrixWorld),a=i.clone();a.project(t),r.setFromCamera(a,t);const m=r.intersectObjects(s,!0);if(m.length){const v=m[0].distance;return i.distanceTo(r.ray.origin)<v}return!0}function Le(e,t){if(t instanceof ie)return t.zoom;if(t instanceof ae){const r=C.setFromMatrixPosition(e.matrixWorld),s=Z.setFromMatrixPosition(t.matrixWorld),i=t.fov*Math.PI/180,a=r.distanceTo(s);return 1/(2*Math.tan(i/2)*a)}else return 1}function Ae(e,t,r){if(t instanceof ae||t instanceof ie){const s=C.setFromMatrixPosition(e.matrixWorld),i=Z.setFromMatrixPosition(t.matrixWorld),a=s.distanceTo(i),m=(r[1]-r[0])/(t.far-t.near),v=r[1]-m*t.far;return Math.round(m*a+v)}}const G=e=>Math.abs(e)<1e-10?0:e;function le(e,t,r=""){let s="matrix3d(";for(let i=0;i!==16;i++)s+=G(t[i]*e.elements[i])+(i!==15?",":")");return r+s}const ze=(e=>t=>le(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Ie=(e=>(t,r)=>le(t,e(r),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Ve(e){return e&&typeof e=="object"&&"current"in e}const _e=n.forwardRef(({children:e,eps:t=.001,style:r,className:s,prepend:i,center:a,fullscreen:m,portal:v,distanceFactor:E,sprite:de=!1,transform:x=!1,occlude:l,onOcclude:q,castShadow:he,receiveShadow:fe,material:me,geometry:J,zIndexRange:T=[16777271,0],calculatePosition:K=Fe,as:xe="div",wrapperClass:z,pointerEvents:Q="auto",...p},U)=>{const{gl:X,camera:c,scene:Y,size:d,raycaster:ve,events:pe,viewport:ge}=Re(),[u]=n.useState(()=>document.createElement(xe)),I=n.useRef(),f=n.useRef(null),ee=n.useRef(0),$=n.useRef([0,0]),R=n.useRef(null),V=n.useRef(null),S=(v==null?void 0:v.current)||pe.connected||X.domElement.parentNode,M=n.useRef(null),F=n.useRef(!1),H=n.useMemo(()=>l&&l!=="blending"||Array.isArray(l)&&l.length&&Ve(l[0]),[l]);n.useLayoutEffect(()=>{const h=X.domElement;l&&l==="blending"?(h.style.zIndex=`${Math.floor(T[0]/2)}`,h.style.position="absolute",h.style.pointerEvents="none"):(h.style.zIndex=null,h.style.position=null,h.style.pointerEvents=null)},[l]),n.useLayoutEffect(()=>{if(f.current){const h=I.current=We(u);if(Y.updateMatrixWorld(),x)u.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const o=K(f.current,c,d);u.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${o[0]}px,${o[1]}px,0);transform-origin:0 0;`}return S&&(i?S.prepend(u):S.appendChild(u)),()=>{S&&S.removeChild(u),h.unmount()}}},[S,x]),n.useLayoutEffect(()=>{z&&(u.className=z)},[z]);const te=n.useMemo(()=>x?{position:"absolute",top:0,left:0,width:d.width,height:d.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:a?"translate3d(-50%,-50%,0)":"none",...m&&{top:-d.height/2,left:-d.width/2,width:d.width,height:d.height},...r},[r,a,m,d,x]),ye=n.useMemo(()=>({position:"absolute",pointerEvents:Q}),[Q]);n.useLayoutEffect(()=>{if(F.current=!1,x){var h;(h=I.current)==null||h.render(n.createElement("div",{ref:R,style:te},n.createElement("div",{ref:V,style:ye},n.createElement("div",{ref:U,className:s,style:r,children:e}))))}else{var o;(o=I.current)==null||o.render(n.createElement("div",{ref:U,style:te,className:s,children:e}))}});const j=n.useRef(!0);Ce(h=>{if(f.current){c.updateMatrixWorld(),f.current.updateWorldMatrix(!0,!1);const o=x?$.current:K(f.current,c,d);if(x||Math.abs(ee.current-c.zoom)>t||Math.abs($.current[0]-o[0])>t||Math.abs($.current[1]-o[1])>t){const P=He(f.current,c);let g=!1;H&&(Array.isArray(l)?g=l.map(b=>b.current):l!=="blending"&&(g=[Y]));const W=j.current;if(g){const b=De(f.current,c,ve,g);j.current=b&&!P}else j.current=!P;W!==j.current&&(q?q(!j.current):u.style.display=j.current?"block":"none");const D=Math.floor(T[0]/2),Me=l?H?[T[0],D]:[D-1,0]:T;if(u.style.zIndex=`${Ae(f.current,c,Me)}`,x){const[b,ne]=[d.width/2,d.height/2],_=c.projectionMatrix.elements[5]*ne,{isOrthographicCamera:se,top:Pe,left:be,bottom:we,right:Se}=c,je=ze(c.matrixWorldInverse),Ee=se?`scale(${_})translate(${G(-(Se+be)/2)}px,${G((Pe+we)/2)}px)`:`translateZ(${_}px)`;let w=f.current.matrixWorld;de&&(w=c.matrixWorldInverse.clone().transpose().copyPosition(w).scale(f.current.scale),w.elements[3]=w.elements[7]=w.elements[11]=0,w.elements[15]=1),u.style.width=d.width+"px",u.style.height=d.height+"px",u.style.perspective=se?"":`${_}px`,R.current&&V.current&&(R.current.style.transform=`${Ee}${je}translate(${b}px,${ne}px)`,V.current.style.transform=Ie(w,1/((E||10)/400)))}else{const b=E===void 0?1:Le(f.current,c)*E;u.style.transform=`translate3d(${o[0]}px,${o[1]}px,0) scale(${b})`}$.current=o,ee.current=c.zoom}}if(!H&&M.current&&!F.current)if(x){if(R.current){const o=R.current.children[0];if(o!=null&&o.clientWidth&&o!=null&&o.clientHeight){const{isOrthographicCamera:P}=c;if(P||J)p.scale&&(Array.isArray(p.scale)?p.scale instanceof A?M.current.scale.copy(p.scale.clone().divideScalar(1)):M.current.scale.set(1/p.scale[0],1/p.scale[1],1/p.scale[2]):M.current.scale.setScalar(1/p.scale));else{const g=(E||10)/400,W=o.clientWidth*g,D=o.clientHeight*g;M.current.scale.set(W,D,1)}F.current=!0}}}else{const o=u.children[0];if(o!=null&&o.clientWidth&&o!=null&&o.clientHeight){const P=1/ge.factor,g=o.clientWidth*P,W=o.clientHeight*P;M.current.scale.set(g,W,1),F.current=!0}M.current.lookAt(h.camera.position)}});const re=n.useMemo(()=>({vertexShader:x?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[x]);return n.createElement("group",oe({},p,{ref:f}),l&&!H&&n.createElement("mesh",{castShadow:he,receiveShadow:fe,ref:M},J||n.createElement("planeGeometry",null),me||n.createElement("shaderMaterial",{side:Oe,vertexShader:re.vertexShader,fragmentShader:re.fragmentShader})))});let L=null,ce="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function ue(e,t,r){return s=>{r&&r(s),e&&(L||(L=new Te),L.setDecoderPath(typeof e=="string"?e:ce),s.setDRACOLoader(L)),t&&s.setMeshoptDecoder(typeof k=="function"?k():k)}}function O(e,t=!0,r=!0,s){return N(B,e,ue(t,r,s))}O.preload=(e,t=!0,r=!0,s)=>N.preload(B,e,ue(t,r,s));O.clear=e=>N.clear(B,e);O.setDecoderPath=e=>{ce=e};function ke(e,t){const r=e+"Geometry";return n.forwardRef(({args:s,children:i,...a},m)=>{const v=n.useRef(null);return n.useImperativeHandle(m,()=>v.current),n.useLayoutEffect(()=>void(t==null?void 0:t(v.current))),n.createElement("mesh",oe({ref:v},a),n.createElement(r,{attach:"geometry",args:s}),i)})}const Ge=ke("plane"),Ne="_htmlMain_1lssb_1",Be={htmlMain:Ne};function qe(e){const{nodes:t,materials:r}=O("./scfiprjt.glb"),s=e.Hovered;return y.jsxs("group",{...e,dispose:null,children:[y.jsxs("group",{rotation:[-Math.PI/2,0,0],scale:[9.506,1.292,3.378],children:[y.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Plane001_1.geometry,material:r["Material.001"]}),y.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Plane001_2.geometry,material:r["Material.011"]})]}),y.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Cube.geometry,material:r["Material.013"],position:[6.432,4.385,-.217],scale:[.456,.176,.542],children:y.jsx(Ge,{visible:!1,scale:[33,30,3],position:[-14.4,-25,.2],children:y.jsx(_e,{className:Be.htmlMain,"rotation-x":-Math.PI*2,position:[1e-4,0,1],transform:!0,scale:.08,center:!0,style:{opacity:"0.8",width:"100%",height:"100%"},children:y.jsx("div",{style:{height:"100%"},onPointerDown:i=>i.stopPropagation(),children:s})})})}),y.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.BezierCurve.geometry,material:r["Material.002"]})]})}O.preload("./scfiprjt.glb");export{qe as default};
