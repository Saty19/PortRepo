import{r,a4 as Pe,at as Me,a5 as re,l as H,au as je,e as _e,ap as ie,P as ne,j as i,av as ae,aw as $}from"./index-dd940f0a.js";const B=new H,N=new H,Ce=new H;function Te(t,e,o){const n=B.setFromMatrixPosition(t.matrixWorld);n.project(e);const s=o.width/2,l=o.height/2;return[n.x*s+s,-(n.y*l)+l]}function ke(t,e){const o=B.setFromMatrixPosition(t.matrixWorld),n=N.setFromMatrixPosition(e.matrixWorld),s=o.sub(n),l=e.getWorldDirection(Ce);return s.angleTo(l)>Math.PI/2}function Ee(t,e,o,n){const s=B.setFromMatrixPosition(t.matrixWorld),l=s.clone();l.project(e),o.setFromCamera(l,e);const g=o.intersectObjects(n,!0);if(g.length){const v=g[0].distance;return s.distanceTo(o.ray.origin)<v}return!0}function Be(t,e){if(e instanceof ie)return e.zoom;if(e instanceof ne){const o=B.setFromMatrixPosition(t.matrixWorld),n=N.setFromMatrixPosition(e.matrixWorld),s=e.fov*Math.PI/180,l=o.distanceTo(n);return 1/(2*Math.tan(s/2)*l)}else return 1}function We(t,e,o){if(e instanceof ne||e instanceof ie){const n=B.setFromMatrixPosition(t.matrixWorld),s=N.setFromMatrixPosition(e.matrixWorld),l=n.distanceTo(s),g=(o[1]-o[0])/(e.far-e.near),v=o[1]-g*e.far;return Math.round(g*l+v)}}const D=t=>Math.abs(t)<1e-10?0:t;function se(t,e,o=""){let n="matrix3d(";for(let s=0;s!==16;s++)n+=D(e[s]*t.elements[s])+(s!==15?",":")");return o+n}const Re=(t=>e=>se(e,t))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Ae=(t=>(e,o)=>se(e,t(o),"translate(-50%,-50%)"))(t=>[1/t,1/t,1/t,1,-1/t,-1/t,-1/t,-1,1/t,1/t,1/t,1,1,1,1,1]);function Oe(t){return t&&typeof t=="object"&&"current"in t}const Le=r.forwardRef(({children:t,eps:e=.001,style:o,className:n,prepend:s,center:l,fullscreen:g,portal:v,distanceFactor:b,sprite:T=!1,transform:d=!1,occlude:c,onOcclude:S,castShadow:ce,receiveShadow:le,material:ue,geometry:G,zIndexRange:W=[16777271,0],calculatePosition:U=Te,as:me="div",wrapperClass:F,pointerEvents:Z="auto",...p},K)=>{const{gl:J,camera:u,scene:Q,size:h,raycaster:de,events:he,viewport:xe}=Pe(),[m]=r.useState(()=>document.createElement(me)),I=r.useRef(),f=r.useRef(null),X=r.useRef(0),R=r.useRef([0,0]),k=r.useRef(null),V=r.useRef(null),_=(v==null?void 0:v.current)||he.connected||J.domElement.parentNode,w=r.useRef(null),A=r.useRef(!1),O=r.useMemo(()=>c&&c!=="blending"||Array.isArray(c)&&c.length&&Oe(c[0]),[c]);r.useLayoutEffect(()=>{const x=J.domElement;c&&c==="blending"?(x.style.zIndex=`${Math.floor(W[0]/2)}`,x.style.position="absolute",x.style.pointerEvents="none"):(x.style.zIndex=null,x.style.position=null,x.style.pointerEvents=null)},[c]),r.useLayoutEffect(()=>{if(f.current){const x=I.current=Me(m);if(Q.updateMatrixWorld(),d)m.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const a=U(f.current,u,h);m.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${a[0]}px,${a[1]}px,0);transform-origin:0 0;`}return _&&(s?_.prepend(m):_.appendChild(m)),()=>{_&&_.removeChild(m),x.unmount()}}},[_,d]),r.useLayoutEffect(()=>{F&&(m.className=F)},[F]);const Y=r.useMemo(()=>d?{position:"absolute",top:0,left:0,width:h.width,height:h.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:l?"translate3d(-50%,-50%,0)":"none",...g&&{top:-h.height/2,left:-h.width/2,width:h.width,height:h.height},...o},[o,l,g,h,d]),fe=r.useMemo(()=>({position:"absolute",pointerEvents:Z}),[Z]);r.useLayoutEffect(()=>{if(A.current=!1,d){var x;(x=I.current)==null||x.render(r.createElement("div",{ref:k,style:Y},r.createElement("div",{ref:V,style:fe},r.createElement("div",{ref:K,className:n,style:o,children:t}))))}else{var a;(a=I.current)==null||a.render(r.createElement("div",{ref:K,style:Y,className:n,children:t}))}});const C=r.useRef(!0);re(x=>{if(f.current){u.updateMatrixWorld(),f.current.updateWorldMatrix(!0,!1);const a=d?R.current:U(f.current,u,h);if(d||Math.abs(X.current-u.zoom)>e||Math.abs(R.current[0]-a[0])>e||Math.abs(R.current[1]-a[1])>e){const P=ke(f.current,u);let y=!1;O&&(Array.isArray(c)?y=c.map(M=>M.current):c!=="blending"&&(y=[Q]));const E=C.current;if(y){const M=Ee(f.current,u,de,y);C.current=M&&!P}else C.current=!P;E!==C.current&&(S?S(!C.current):m.style.display=C.current?"block":"none");const L=Math.floor(W[0]/2),ge=c?O?[W[0],L]:[L-1,0]:W;if(m.style.zIndex=`${We(f.current,u,ge)}`,d){const[M,te]=[h.width/2,h.height/2],q=u.projectionMatrix.elements[5]*te,{isOrthographicCamera:oe,top:pe,left:ye,bottom:ve,right:we}=u,be=Re(u.matrixWorldInverse),Se=oe?`scale(${q})translate(${D(-(we+ye)/2)}px,${D((pe+ve)/2)}px)`:`translateZ(${q}px)`;let j=f.current.matrixWorld;T&&(j=u.matrixWorldInverse.clone().transpose().copyPosition(j).scale(f.current.scale),j.elements[3]=j.elements[7]=j.elements[11]=0,j.elements[15]=1),m.style.width=h.width+"px",m.style.height=h.height+"px",m.style.perspective=oe?"":`${q}px`,k.current&&V.current&&(k.current.style.transform=`${Se}${be}translate(${M}px,${te}px)`,V.current.style.transform=Ae(j,1/((b||10)/400)))}else{const M=b===void 0?1:Be(f.current,u)*b;m.style.transform=`translate3d(${a[0]}px,${a[1]}px,0) scale(${M})`}R.current=a,X.current=u.zoom}}if(!O&&w.current&&!A.current)if(d){if(k.current){const a=k.current.children[0];if(a!=null&&a.clientWidth&&a!=null&&a.clientHeight){const{isOrthographicCamera:P}=u;if(P||G)p.scale&&(Array.isArray(p.scale)?p.scale instanceof H?w.current.scale.copy(p.scale.clone().divideScalar(1)):w.current.scale.set(1/p.scale[0],1/p.scale[1],1/p.scale[2]):w.current.scale.setScalar(1/p.scale));else{const y=(b||10)/400,E=a.clientWidth*y,L=a.clientHeight*y;w.current.scale.set(E,L,1)}A.current=!0}}}else{const a=m.children[0];if(a!=null&&a.clientWidth&&a!=null&&a.clientHeight){const P=1/xe.factor,y=a.clientWidth*P,E=a.clientHeight*P;w.current.scale.set(y,E,1),A.current=!0}w.current.lookAt(x.camera.position)}});const ee=r.useMemo(()=>({vertexShader:d?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[d]);return r.createElement("group",je({},p,{ref:f}),c&&!O&&r.createElement("mesh",{castShadow:ce,receiveShadow:le,ref:w},G||r.createElement("planeGeometry",null),ue||r.createElement("shaderMaterial",{side:_e,vertexShader:ee.vertexShader,fragmentShader:ee.fragmentShader})))}),$e="_htmlMain_1cezf_1",ze={htmlMain:$e},z=()=>{const t={height:"900px",backgroundColor:"#f0f0f0",padding:"20px",textAlign:"center"},e={maxWidth:"100%",maxHeight:"400px",margin:"20px 0",borderRadius:"8px"};return i.jsxs("div",{style:t,children:[i.jsx("h1",{children:"Tall Component"}),i.jsx("img",{src:"https://via.placeholder.com/800x400",alt:"Placeholder Image",style:e}),i.jsx("p",{style:{color:"black"},children:"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."})]})},He=()=>{const t={height:"900px",backgroundColor:"#f0f0f0",padding:"20px",textAlign:"center"},e={maxWidth:"100%",maxHeight:"400px",margin:"20px 0",borderRadius:"8px"};return i.jsxs("div",{style:t,children:[i.jsx("h1",{children:"Tall Component"}),i.jsx("img",{src:"https://via.placeholder.com/800x400",alt:"Placeholder Image",style:e}),i.jsx("p",{style:{color:"black"},children:"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."}),i.jsx("h1",{style:{color:"black"},children:"MILAN"})]})};function Ie(t){const{nodes:e,materials:o}=ae("./laptop.glb"),n=r.useRef();re(c=>{const S=c.clock.getElapsedTime();n.current.rotation.x=$.lerp(n.current.rotation.x,open?Math.cos(S/10)/8+.35:0,.1),n.current.rotation.y=$.lerp(n.current.rotation.y,open?Math.sin(S/10)/2:0,.1),n.current.rotation.z=$.lerp(n.current.rotation.z,open?Math.sin(S/10)/4:0,.1),n.current.position.y=$.lerp(n.current.position.y,open?(-2+Math.sin(S))/5:-7,.6)}),r.useEffect(()=>()=>{},[]);const l={MAGENTO:z,REACT:He,ANGULAR:z,PHP:z,LARAVEL:z},g=t.Scale,[v,b]=r.useState(window.innerWidth);r.useEffect(()=>{function c(){b(window.innerWidth)}return()=>{window.removeEventListener("resize",c)}},[]);const T=t==null?void 0:t.Hovered,d=l[T==null?void 0:T.name];return i.jsxs("group",{ref:n,...t,dispose:null,scale:v<=820?g:3.2,"rotation-x":19,position:[0,-10,0],children:[i.jsxs("group",{rotation:[-Math.PI,0,-3.135],children:[i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001.geometry,material:o["Black.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_1.geometry,material:o["Main.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_2.geometry,material:o["Second.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_3.geometry,material:o["KeysMain.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_4.geometry,material:o["KeysBottom.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_5.geometry,material:o["TopLine.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_6.geometry,material:o["DarkGrey.001"]})]}),i.jsxs("group",{rotation:[Math.PI*.85,0,-3.135],children:[i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001.geometry,material:o["Outline.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_1.geometry,children:i.jsx(Le,{className:ze.htmlMain,position:[-.05,1.35,-.001],transform:!0,occlude:!0,"rotation-y":91.11,"rotation-x":94.33,scale:[.07,.088,.07],center:!0,style:{width:"96vw",height:"125vh"},children:i.jsx("div",{style:{height:"100%",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer"},onPointerDown:c=>c.stopPropagation(),children:i.jsx(d,{})})})}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_2.geometry,material:o["Emission.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_3.geometry,material:o["Logo.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_4.geometry,material:o["Main.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_5.geometry,material:o["Text.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_6.geometry,material:o["Camera.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_7.geometry,material:o["Camera1.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_8.geometry,material:o["CameraGreen.001"]})]})]})}ae.preload("./laptop.glb");export{Ie as default};
