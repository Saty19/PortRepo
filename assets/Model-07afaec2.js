import{r as o,u as Se,c as Ee,a as ie,_ as Ce,D as We,V as H,O as se,P as ae,j as s,b as ce,M as k}from"./index-f7313f3a.js";const R=new H,q=new H,Re=new H;function Te(e,t,n){const r=R.setFromMatrixPosition(e.matrixWorld);r.project(t);const a=n.width/2,u=n.height/2;return[r.x*a+a,-(r.y*u)+u]}function Ae(e,t){const n=R.setFromMatrixPosition(e.matrixWorld),r=q.setFromMatrixPosition(t.matrixWorld),a=n.sub(r),u=t.getWorldDirection(Re);return a.angleTo(u)>Math.PI/2}function Oe(e,t,n,r){const a=R.setFromMatrixPosition(e.matrixWorld),u=a.clone();u.project(t),n.setFromCamera(u,t);const g=n.intersectObjects(r,!0);if(g.length){const b=g[0].distance;return a.distanceTo(n.ray.origin)<b}return!0}function $e(e,t){if(t instanceof se)return t.zoom;if(t instanceof ae){const n=R.setFromMatrixPosition(e.matrixWorld),r=q.setFromMatrixPosition(t.matrixWorld),a=t.fov*Math.PI/180,u=n.distanceTo(r);return 1/(2*Math.tan(a/2)*u)}else return 1}function ze(e,t,n){if(t instanceof ae||t instanceof se){const r=R.setFromMatrixPosition(e.matrixWorld),a=q.setFromMatrixPosition(t.matrixWorld),u=r.distanceTo(a),g=(n[1]-n[0])/(t.far-t.near),b=n[1]-g*t.far;return Math.round(g*u+b)}}const I=e=>Math.abs(e)<1e-10?0:e;function le(e,t,n=""){let r="matrix3d(";for(let a=0;a!==16;a++)r+=I(t[a]*e.elements[a])+(a!==15?",":")");return n+r}const ke=(e=>t=>le(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Fe=(e=>(t,n)=>le(t,e(n),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function He(e){return e&&typeof e=="object"&&"current"in e}const Le=o.forwardRef(({children:e,eps:t=.001,style:n,className:r,prepend:a,center:u,fullscreen:g,portal:b,distanceFactor:x,sprite:L=!1,transform:l=!1,occlude:c,onOcclude:G,castShadow:ue,receiveShadow:me,material:de,geometry:B,zIndexRange:T=[16777271,0],calculatePosition:U=Te,as:he="div",wrapperClass:_,pointerEvents:Z="auto",...y},J)=>{const{gl:K,camera:m,scene:Q,size:h,raycaster:fe,events:xe,viewport:pe}=Se(),[d]=o.useState(()=>document.createElement(he)),N=o.useRef(),p=o.useRef(null),X=o.useRef(0),A=o.useRef([0,0]),C=o.useRef(null),V=o.useRef(null),S=(b==null?void 0:b.current)||xe.connected||K.domElement.parentNode,M=o.useRef(null),O=o.useRef(!1),$=o.useMemo(()=>c&&c!=="blending"||Array.isArray(c)&&c.length&&He(c[0]),[c]);o.useLayoutEffect(()=>{const f=K.domElement;c&&c==="blending"?(f.style.zIndex=`${Math.floor(T[0]/2)}`,f.style.position="absolute",f.style.pointerEvents="none"):(f.style.zIndex=null,f.style.position=null,f.style.pointerEvents=null)},[c]),o.useLayoutEffect(()=>{if(p.current){const f=N.current=Ee(d);if(Q.updateMatrixWorld(),l)d.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const i=U(p.current,m,h);d.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${i[0]}px,${i[1]}px,0);transform-origin:0 0;`}return S&&(a?S.prepend(d):S.appendChild(d)),()=>{S&&S.removeChild(d),f.unmount()}}},[S,l]),o.useLayoutEffect(()=>{_&&(d.className=_)},[_]);const Y=o.useMemo(()=>l?{position:"absolute",top:0,left:0,width:h.width,height:h.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:u?"translate3d(-50%,-50%,0)":"none",...g&&{top:-h.height/2,left:-h.width/2,width:h.width,height:h.height},...n},[n,u,g,h,l]),ge=o.useMemo(()=>({position:"absolute",pointerEvents:Z}),[Z]);o.useLayoutEffect(()=>{if(O.current=!1,l){var f;(f=N.current)==null||f.render(o.createElement("div",{ref:C,style:Y},o.createElement("div",{ref:V,style:ge},o.createElement("div",{ref:J,className:r,style:n,children:e}))))}else{var i;(i=N.current)==null||i.render(o.createElement("div",{ref:J,style:Y,className:r,children:e}))}});const E=o.useRef(!0);ie(f=>{if(p.current){m.updateMatrixWorld(),p.current.updateWorldMatrix(!0,!1);const i=l?A.current:U(p.current,m,h);if(l||Math.abs(X.current-m.zoom)>t||Math.abs(A.current[0]-i[0])>t||Math.abs(A.current[1]-i[1])>t){const P=Ae(p.current,m);let v=!1;$&&(Array.isArray(c)?v=c.map(w=>w.current):c!=="blending"&&(v=[Q]));const W=E.current;if(v){const w=Oe(p.current,m,fe,v);E.current=w&&!P}else E.current=!P;W!==E.current&&(G?G(!E.current):d.style.display=E.current?"block":"none");const z=Math.floor(T[0]/2),ye=c?$?[T[0],z]:[z-1,0]:T;if(d.style.zIndex=`${ze(p.current,m,ye)}`,l){const[w,te]=[h.width/2,h.height/2],D=m.projectionMatrix.elements[5]*te,{isOrthographicCamera:ne,top:ve,left:be,bottom:Me,right:Pe}=m,we=ke(m.matrixWorldInverse),je=ne?`scale(${D})translate(${I(-(Pe+be)/2)}px,${I((ve+Me)/2)}px)`:`translateZ(${D}px)`;let j=p.current.matrixWorld;L&&(j=m.matrixWorldInverse.clone().transpose().copyPosition(j).scale(p.current.scale),j.elements[3]=j.elements[7]=j.elements[11]=0,j.elements[15]=1),d.style.width=h.width+"px",d.style.height=h.height+"px",d.style.perspective=ne?"":`${D}px`,C.current&&V.current&&(C.current.style.transform=`${je}${we}translate(${w}px,${te}px)`,V.current.style.transform=Fe(j,1/((x||10)/400)))}else{const w=x===void 0?1:$e(p.current,m)*x;d.style.transform=`translate3d(${i[0]}px,${i[1]}px,0) scale(${w})`}A.current=i,X.current=m.zoom}}if(!$&&M.current&&!O.current)if(l){if(C.current){const i=C.current.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const{isOrthographicCamera:P}=m;if(P||B)y.scale&&(Array.isArray(y.scale)?y.scale instanceof H?M.current.scale.copy(y.scale.clone().divideScalar(1)):M.current.scale.set(1/y.scale[0],1/y.scale[1],1/y.scale[2]):M.current.scale.setScalar(1/y.scale));else{const v=(x||10)/400,W=i.clientWidth*v,z=i.clientHeight*v;M.current.scale.set(W,z,1)}O.current=!0}}}else{const i=d.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const P=1/pe.factor,v=i.clientWidth*P,W=i.clientHeight*P;M.current.scale.set(v,W,1),O.current=!0}M.current.lookAt(f.camera.position)}});const ee=o.useMemo(()=>({vertexShader:l?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[l]);return o.createElement("group",Ce({},y,{ref:p}),c&&!$&&o.createElement("mesh",{castShadow:ue,receiveShadow:me,ref:M},B||o.createElement("planeGeometry",null),de||o.createElement("shaderMaterial",{side:We,vertexShader:ee.vertexShader,fragmentShader:ee.fragmentShader})))}),_e="_content_17mq6_2",Ne="_wrapper_17mq6_13",oe={content:_e,wrapper:Ne},F=()=>{const e={height:"100vh",width:"190%",backgroundColor:"#f0f0f0",textAlign:"center"},t={maxWidth:"100%",maxHeight:"400px",margin:"20px 0",borderRadius:"8px"};return s.jsxs("div",{style:e,children:[s.jsx("h1",{children:"Tall Component"}),s.jsx("img",{src:"https://via.placeholder.com/800x400",alt:"Placeholder Image",style:t}),s.jsx("p",{style:{color:"black"},children:"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."})]})},Ve=()=>{const e={height:"100vh",width:"190%",padding:"10px",transform:"scale(0.5)",transformOrigin:"top left",backgroundColor:"#121212",boxShadow:"0 0 10px rgba(0, 0, 0, 0.1)",textAlign:"center"},t={color:"#333",fontSize:"24px",marginBottom:"15px"},n={color:"#666",fontSize:"16px"};return s.jsxs("div",{style:e,children:[s.jsx("h2",{style:t,children:"Simple Component"}),s.jsx("p",{style:n,children:"This is a simple React component with inline styles."})]})},re=Ve;function Ie(e){const{nodes:t,materials:n}=ce("./mac-draco.glb"),r=o.useRef();ie(l=>{const c=l.clock.getElapsedTime();r.current.rotation.x=k.lerp(r.current.rotation.x,Math.cos(c/2)/20+.25,.1),r.current.rotation.y=k.lerp(r.current.rotation.y,Math.sin(c/4)/20,.1),r.current.rotation.z=k.lerp(r.current.rotation.z,Math.sin(c/8)/20,.1),r.current.position.y=k.lerp(r.current.position.y,(-2+Math.sin(c/2))/2,.1)});const u={MAGENTO:F,REACT:re,ANGULAR:F,PHP:F,LARAVEL:F};e.Scale;const[g,b]=o.useState(window.innerWidth);o.useLayoutEffect(()=>{function l(){b(window.innerWidth)}return()=>{window.removeEventListener("resize",l)}},[]);const x=e==null?void 0:e.Hovered;u[x==null?void 0:x.name];const L=g<810?[0,.05,0]:[.35,.05,-.5];return s.jsxs("group",{ref:r,...e,dispose:null,children:[s.jsx("group",{"rotation-x":-.425,position:[0,-.04,.41],children:s.jsxs("group",{position:[0,2.96,-.13],rotation:[Math.PI/2,0,0],children:[s.jsx("mesh",{material:n.aluminium,geometry:t.Cube008.geometry}),s.jsx("mesh",{material:n["matte.001"],geometry:t.Cube008_1.geometry}),s.jsx("mesh",{geometry:t.Cube008_2.geometry,children:s.jsx(Le,{className:oe.content,"rotation-x":-Math.PI/2,position:L,transform:!0,occlude:!0,children:s.jsx("div",{className:oe.wrapper,onPointerDown:l=>l.stopPropagation(),children:(x==null?void 0:x.name)=="MAGENTO"&&s.jsx(re,{})})})})]})}),s.jsx("mesh",{material:n.keys,geometry:t.keyboard.geometry,position:[1.79,0,3.45]}),s.jsxs("group",{position:[0,-.1,3.39],children:[s.jsx("mesh",{material:n.aluminium,geometry:t.Cube002.geometry}),s.jsx("mesh",{material:n.trackpad,geometry:t.Cube002_1.geometry})]}),s.jsx("mesh",{material:n.touchbar,geometry:t.touchbar.geometry,position:[0,-.03,1.2]})]})}ce.preload("./mac-draco.glb");export{Ie as default};
