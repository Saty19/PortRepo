import{r as n,c as Re,j as p}from"./index-4af5c2d4.js";import{u as We,a as se,_ as ie,D as Te,V as z,O as ae,P as ce,b as _,G as B,c as De,M as G}from"./Projects-ae901af6.js";const W=new z,Z=new z,Oe=new z;function $e(e,t,r){const o=W.setFromMatrixPosition(e.matrixWorld);o.project(t);const s=r.width/2,a=r.height/2;return[o.x*s+s,-(o.y*a)+a]}function Fe(e,t){const r=W.setFromMatrixPosition(e.matrixWorld),o=Z.setFromMatrixPosition(t.matrixWorld),s=r.sub(o),a=t.getWorldDirection(Oe);return s.angleTo(a)>Math.PI/2}function He(e,t,r,o){const s=W.setFromMatrixPosition(e.matrixWorld),a=s.clone();a.project(t),r.setFromCamera(a,t);const c=r.intersectObjects(o,!0);if(c.length){const l=c[0].distance;return s.distanceTo(r.ray.origin)<l}return!0}function Le(e,t){if(t instanceof ae)return t.zoom;if(t instanceof ce){const r=W.setFromMatrixPosition(e.matrixWorld),o=Z.setFromMatrixPosition(t.matrixWorld),s=t.fov*Math.PI/180,a=r.distanceTo(o);return 1/(2*Math.tan(s/2)*a)}else return 1}function ze(e,t,r){if(t instanceof ce||t instanceof ae){const o=W.setFromMatrixPosition(e.matrixWorld),s=Z.setFromMatrixPosition(t.matrixWorld),a=o.distanceTo(s),c=(r[1]-r[0])/(t.far-t.near),l=r[1]-c*t.far;return Math.round(c*a+l)}}const N=e=>Math.abs(e)<1e-10?0:e;function le(e,t,r=""){let o="matrix3d(";for(let s=0;s!==16;s++)o+=N(t[s]*e.elements[s])+(s!==15?",":")");return r+o}const Ae=(e=>t=>le(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Ve=(e=>(t,r)=>le(t,e(r),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Ie(e){return e&&typeof e=="object"&&"current"in e}const ke=n.forwardRef(({children:e,eps:t=.001,style:r,className:o,prepend:s,center:a,fullscreen:c,portal:l,distanceFactor:g,sprite:he=!1,transform:y=!1,occlude:u,onOcclude:q,castShadow:me,receiveShadow:fe,material:xe,geometry:J,zIndexRange:D=[16777271,0],calculatePosition:K=$e,as:pe="div",wrapperClass:A,pointerEvents:Q="auto",...v},U)=>{const{gl:X,camera:d,scene:Y,size:m,raycaster:ye,events:ge,viewport:ve}=We(),[h]=n.useState(()=>document.createElement(pe)),V=n.useRef(),x=n.useRef(null),ee=n.useRef(0),O=n.useRef([0,0]),C=n.useRef(null),I=n.useRef(null),j=(l==null?void 0:l.current)||ge.connected||X.domElement.parentNode,P=n.useRef(null),$=n.useRef(!1),F=n.useMemo(()=>u&&u!=="blending"||Array.isArray(u)&&u.length&&Ie(u[0]),[u]);n.useLayoutEffect(()=>{const f=X.domElement;u&&u==="blending"?(f.style.zIndex=`${Math.floor(D[0]/2)}`,f.style.position="absolute",f.style.pointerEvents="none"):(f.style.zIndex=null,f.style.position=null,f.style.pointerEvents=null)},[u]),n.useLayoutEffect(()=>{if(x.current){const f=V.current=Re(h);if(Y.updateMatrixWorld(),y)h.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const i=K(x.current,d,m);h.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${i[0]}px,${i[1]}px,0);transform-origin:0 0;`}return j&&(s?j.prepend(h):j.appendChild(h)),()=>{j&&j.removeChild(h),f.unmount()}}},[j,y]),n.useLayoutEffect(()=>{A&&(h.className=A)},[A]);const te=n.useMemo(()=>y?{position:"absolute",top:0,left:0,width:m.width,height:m.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:a?"translate3d(-50%,-50%,0)":"none",...c&&{top:-m.height/2,left:-m.width/2,width:m.width,height:m.height},...r},[r,a,c,m,y]),Me=n.useMemo(()=>({position:"absolute",pointerEvents:Q}),[Q]);n.useLayoutEffect(()=>{if($.current=!1,y){var f;(f=V.current)==null||f.render(n.createElement("div",{ref:C,style:te},n.createElement("div",{ref:I,style:Me},n.createElement("div",{ref:U,className:o,style:r,children:e}))))}else{var i;(i=V.current)==null||i.render(n.createElement("div",{ref:U,style:te,className:o,children:e}))}});const E=n.useRef(!0);se(f=>{if(x.current){d.updateMatrixWorld(),x.current.updateWorldMatrix(!0,!1);const i=y?O.current:K(x.current,d,m);if(y||Math.abs(ee.current-d.zoom)>t||Math.abs(O.current[0]-i[0])>t||Math.abs(O.current[1]-i[1])>t){const b=Fe(x.current,d);let M=!1;F&&(Array.isArray(u)?M=u.map(w=>w.current):u!=="blending"&&(M=[Y]));const R=E.current;if(M){const w=He(x.current,d,ye,M);E.current=w&&!b}else E.current=!b;R!==E.current&&(q?q(!E.current):h.style.display=E.current?"block":"none");const H=Math.floor(D[0]/2),Pe=u?F?[D[0],H]:[H-1,0]:D;if(h.style.zIndex=`${ze(x.current,d,Pe)}`,y){const[w,ne]=[m.width/2,m.height/2],k=d.projectionMatrix.elements[5]*ne,{isOrthographicCamera:oe,top:be,left:we,bottom:Se,right:je}=d,Ee=Ae(d.matrixWorldInverse),Ce=oe?`scale(${k})translate(${N(-(je+we)/2)}px,${N((be+Se)/2)}px)`:`translateZ(${k}px)`;let S=x.current.matrixWorld;he&&(S=d.matrixWorldInverse.clone().transpose().copyPosition(S).scale(x.current.scale),S.elements[3]=S.elements[7]=S.elements[11]=0,S.elements[15]=1),h.style.width=m.width+"px",h.style.height=m.height+"px",h.style.perspective=oe?"":`${k}px`,C.current&&I.current&&(C.current.style.transform=`${Ce}${Ee}translate(${w}px,${ne}px)`,I.current.style.transform=Ve(S,1/((g||10)/400)))}else{const w=g===void 0?1:Le(x.current,d)*g;h.style.transform=`translate3d(${i[0]}px,${i[1]}px,0) scale(${w})`}O.current=i,ee.current=d.zoom}}if(!F&&P.current&&!$.current)if(y){if(C.current){const i=C.current.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const{isOrthographicCamera:b}=d;if(b||J)v.scale&&(Array.isArray(v.scale)?v.scale instanceof z?P.current.scale.copy(v.scale.clone().divideScalar(1)):P.current.scale.set(1/v.scale[0],1/v.scale[1],1/v.scale[2]):P.current.scale.setScalar(1/v.scale));else{const M=(g||10)/400,R=i.clientWidth*M,H=i.clientHeight*M;P.current.scale.set(R,H,1)}$.current=!0}}}else{const i=h.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const b=1/ve.factor,M=i.clientWidth*b,R=i.clientHeight*b;P.current.scale.set(M,R,1),$.current=!0}P.current.lookAt(f.camera.position)}});const re=n.useMemo(()=>({vertexShader:y?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[y]);return n.createElement("group",ie({},v,{ref:x}),u&&!F&&n.createElement("mesh",{castShadow:me,receiveShadow:fe,ref:P},J||n.createElement("planeGeometry",null),xe||n.createElement("shaderMaterial",{side:Te,vertexShader:re.vertexShader,fragmentShader:re.fragmentShader})))});let L=null,ue="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function de(e,t,r){return o=>{r&&r(o),e&&(L||(L=new De),L.setDecoderPath(typeof e=="string"?e:ue),o.setDRACOLoader(L)),t&&o.setMeshoptDecoder(typeof G=="function"?G():G)}}function T(e,t=!0,r=!0,o){return _(B,e,de(t,r,o))}T.preload=(e,t=!0,r=!0,o)=>_.preload(B,e,de(t,r,o));T.clear=e=>_.clear(B,e);T.setDecoderPath=e=>{ue=e};function Ge(e,t){const r=e+"Geometry";return n.forwardRef(({args:o,children:s,...a},c)=>{const l=n.useRef(null);return n.useImperativeHandle(c,()=>l.current),n.useLayoutEffect(()=>void(t==null?void 0:t(l.current))),n.createElement("mesh",ie({ref:l},a),n.createElement(r,{attach:"geometry",args:o}),s)})}const Ne=Ge("plane"),_e="_htmlMain_1lssb_1",Be={htmlMain:_e};function Je(e){const{nodes:t,materials:r}=T("./TEST.glb"),o=n.useRef(),s=n.useRef(),a=n.useRef(),c=e.Hovered;return se(l=>{const g=l.clock.getElapsedTime();o.current.rotation.set(.1+Math.cos(g/4.5)/10,Math.sin(g/4)/4,.3-(1+Math.sin(g/4))/8),o.current.position.y=(1+Math.sin(g/2))/10,s.current.rotation.y+=.01,a.current.rotation.y+=-.01}),p.jsx("group",{...e,dispose:null,ref:o,children:p.jsxs("group",{scale:[8,8,8],"rotation-x":-25.5,"rotation-y":26.2,"rotation-z":45,children:[p.jsx("group",{ref:s,children:p.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Circle.geometry,material:r["Material.005"],rotation:[0,-1.4,0],scale:1.1,userData:{name:"Circle"}})}),p.jsx("group",{ref:a,children:p.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Circle001.geometry,material:r["Material.006"],position:[0,.1,0],scale:[.9,1.1,.9],userData:{name:"Circle.001"}})}),p.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Circle002.geometry,material:r["Material.007"],position:[0,.3,0],scale:.4,userData:{name:"Circle.002"}}),p.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Circle003.geometry,material:r["Material.008"],position:[0,.2,0],scale:.7,userData:{name:"Circle.003"}}),p.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.Circle004.geometry,material:r["Material.009"],position:[0,.3,0],scale:.2,userData:{name:"Circle.004"},children:p.jsx(Ne,{visible:!1,"rotation-y":-70,scale:[10,10,1],position:[0,2,-1],children:p.jsx(ke,{className:Be.htmlMain,"rotation-x":-Math.PI*2,position:[1e-4,0,1],transform:!0,scale:.08,center:!0,style:{opacity:"0.8",width:"100%",height:"100%"},children:p.jsx("div",{style:{height:"100%",fontSize:"2vw"},onPointerDown:l=>l.stopPropagation(),children:c&&c.name})})})})]})})}T.preload("./TEST.glb");export{Je as default};
