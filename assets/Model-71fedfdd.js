import{r as n,u as Be,c as Ee,a as ae,V as L,_ as Te,D as We,O as ce,P as le,b as Z,G as K,d as ke,M as G,j as i,S as Re,e as D}from"./index-a1373409.js";const T=new L,U=new L,Oe=new L;function $e(t,e,r){const o=T.setFromMatrixPosition(t.matrixWorld);o.project(e);const a=r.width/2,c=r.height/2;return[o.x*a+a,-(o.y*c)+c]}function ze(t,e){const r=T.setFromMatrixPosition(t.matrixWorld),o=U.setFromMatrixPosition(e.matrixWorld),a=r.sub(o),c=e.getWorldDirection(Oe);return a.angleTo(c)>Math.PI/2}function De(t,e,r,o){const a=T.setFromMatrixPosition(t.matrixWorld),c=a.clone();c.project(e),r.setFromCamera(c,e);const y=r.intersectObjects(o,!0);if(y.length){const w=y[0].distance;return a.distanceTo(r.ray.origin)<w}return!0}function Fe(t,e){if(e instanceof ce)return e.zoom;if(e instanceof le){const r=T.setFromMatrixPosition(t.matrixWorld),o=U.setFromMatrixPosition(e.matrixWorld),a=e.fov*Math.PI/180,c=r.distanceTo(o);return 1/(2*Math.tan(a/2)*c)}else return 1}function Le(t,e,r){if(e instanceof le||e instanceof ce){const o=T.setFromMatrixPosition(t.matrixWorld),a=U.setFromMatrixPosition(e.matrixWorld),c=o.distanceTo(a),y=(r[1]-r[0])/(e.far-e.near),w=r[1]-y*e.far;return Math.round(y*c+w)}}const N=t=>Math.abs(t)<1e-10?0:t;function ue(t,e,r=""){let o="matrix3d(";for(let a=0;a!==16;a++)o+=N(e[a]*t.elements[a])+(a!==15?",":")");return r+o}const Ae=(t=>e=>ue(e,t))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),He=(t=>(e,r)=>ue(e,t(r),"translate(-50%,-50%)"))(t=>[1/t,1/t,1/t,1,-1/t,-1/t,-1/t,-1,1/t,1/t,1/t,1,1,1,1,1]);function Ie(t){return t&&typeof t=="object"&&"current"in t}const Ve=n.forwardRef(({children:t,eps:e=.001,style:r,className:o,prepend:a,center:c,fullscreen:y,portal:w,distanceFactor:g,sprite:P=!1,transform:l=!1,occlude:u,onOcclude:q,castShadow:he,receiveShadow:fe,material:xe,geometry:J,zIndexRange:k=[16777271,0],calculatePosition:Q=$e,as:ye="div",wrapperClass:A,pointerEvents:X="auto",...p},Y)=>{const{gl:ee,camera:m,scene:te,size:h,raycaster:ge,events:pe,viewport:ve}=Be(),[d]=n.useState(()=>document.createElement(ye)),H=n.useRef(),x=n.useRef(null),re=n.useRef(0),R=n.useRef([0,0]),B=n.useRef(null),I=n.useRef(null),j=(w==null?void 0:w.current)||pe.connected||ee.domElement.parentNode,M=n.useRef(null),O=n.useRef(!1),$=n.useMemo(()=>u&&u!=="blending"||Array.isArray(u)&&u.length&&Ie(u[0]),[u]);n.useLayoutEffect(()=>{const f=ee.domElement;u&&u==="blending"?(f.style.zIndex=`${Math.floor(k[0]/2)}`,f.style.position="absolute",f.style.pointerEvents="none"):(f.style.zIndex=null,f.style.position=null,f.style.pointerEvents=null)},[u]),n.useLayoutEffect(()=>{if(x.current){const f=H.current=Ee(d);if(te.updateMatrixWorld(),l)d.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const s=Q(x.current,m,h);d.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${s[0]}px,${s[1]}px,0);transform-origin:0 0;`}return j&&(a?j.prepend(d):j.appendChild(d)),()=>{j&&j.removeChild(d),f.unmount()}}},[j,l]),n.useLayoutEffect(()=>{A&&(d.className=A)},[A]);const oe=n.useMemo(()=>l?{position:"absolute",top:0,left:0,width:h.width,height:h.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:c?"translate3d(-50%,-50%,0)":"none",...y&&{top:-h.height/2,left:-h.width/2,width:h.width,height:h.height},...r},[r,c,y,h,l]),we=n.useMemo(()=>({position:"absolute",pointerEvents:X}),[X]);n.useLayoutEffect(()=>{if(O.current=!1,l){var f;(f=H.current)==null||f.render(n.createElement("div",{ref:B,style:oe},n.createElement("div",{ref:I,style:we},n.createElement("div",{ref:Y,className:o,style:r,children:t}))))}else{var s;(s=H.current)==null||s.render(n.createElement("div",{ref:Y,style:oe,className:o,children:t}))}});const C=n.useRef(!0);ae(f=>{if(x.current){m.updateMatrixWorld(),x.current.updateWorldMatrix(!0,!1);const s=l?R.current:Q(x.current,m,h);if(l||Math.abs(re.current-m.zoom)>e||Math.abs(R.current[0]-s[0])>e||Math.abs(R.current[1]-s[1])>e){const S=ze(x.current,m);let v=!1;$&&(Array.isArray(u)?v=u.map(b=>b.current):u!=="blending"&&(v=[te]));const E=C.current;if(v){const b=De(x.current,m,ge,v);C.current=b&&!S}else C.current=!S;E!==C.current&&(q?q(!C.current):d.style.display=C.current?"block":"none");const z=Math.floor(k[0]/2),Me=u?$?[k[0],z]:[z-1,0]:k;if(d.style.zIndex=`${Le(x.current,m,Me)}`,l){const[b,se]=[h.width/2,h.height/2],V=m.projectionMatrix.elements[5]*se,{isOrthographicCamera:ie,top:Pe,left:Se,bottom:be,right:_e}=m,je=Ae(m.matrixWorldInverse),Ce=ie?`scale(${V})translate(${N(-(_e+Se)/2)}px,${N((Pe+be)/2)}px)`:`translateZ(${V}px)`;let _=x.current.matrixWorld;P&&(_=m.matrixWorldInverse.clone().transpose().copyPosition(_).scale(x.current.scale),_.elements[3]=_.elements[7]=_.elements[11]=0,_.elements[15]=1),d.style.width=h.width+"px",d.style.height=h.height+"px",d.style.perspective=ie?"":`${V}px`,B.current&&I.current&&(B.current.style.transform=`${Ce}${je}translate(${b}px,${se}px)`,I.current.style.transform=He(_,1/((g||10)/400)))}else{const b=g===void 0?1:Fe(x.current,m)*g;d.style.transform=`translate3d(${s[0]}px,${s[1]}px,0) scale(${b})`}R.current=s,re.current=m.zoom}}if(!$&&M.current&&!O.current)if(l){if(B.current){const s=B.current.children[0];if(s!=null&&s.clientWidth&&s!=null&&s.clientHeight){const{isOrthographicCamera:S}=m;if(S||J)p.scale&&(Array.isArray(p.scale)?p.scale instanceof L?M.current.scale.copy(p.scale.clone().divideScalar(1)):M.current.scale.set(1/p.scale[0],1/p.scale[1],1/p.scale[2]):M.current.scale.setScalar(1/p.scale));else{const v=(g||10)/400,E=s.clientWidth*v,z=s.clientHeight*v;M.current.scale.set(E,z,1)}O.current=!0}}}else{const s=d.children[0];if(s!=null&&s.clientWidth&&s!=null&&s.clientHeight){const S=1/ve.factor,v=s.clientWidth*S,E=s.clientHeight*S;M.current.scale.set(v,E,1),O.current=!0}M.current.lookAt(f.camera.position)}});const ne=n.useMemo(()=>({vertexShader:l?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[l]);return n.createElement("group",Te({},p,{ref:x}),u&&!$&&n.createElement("mesh",{castShadow:he,receiveShadow:fe,ref:M},J||n.createElement("planeGeometry",null),xe||n.createElement("shaderMaterial",{side:We,vertexShader:ne.vertexShader,fragmentShader:ne.fragmentShader})))});let F=null,me="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function de(t,e,r){return o=>{r&&r(o),t&&(F||(F=new ke),F.setDecoderPath(typeof t=="string"?t:me),o.setDRACOLoader(F)),e&&o.setMeshoptDecoder(typeof G=="function"?G():G)}}function W(t,e=!0,r=!0,o){return Z(K,t,de(e,r,o))}W.preload=(t,e=!0,r=!0,o)=>Z.preload(K,t,de(e,r,o));W.clear=t=>Z.clear(K,t);W.setDecoderPath=t=>{me=t};const Ge="_htmlMain_1cezf_1",Ne={htmlMain:Ge};function Ke(t){const{nodes:e,materials:r}=W("./laptop.glb"),o=n.useRef();ae(P=>{const l=P.clock.getElapsedTime();o.current.rotation.x=D.lerp(o.current.rotation.x,open?Math.cos(l/10)/7+.25:0,.1),o.current.rotation.y=D.lerp(o.current.rotation.y,open?Math.sin(l/10)/2:0,.1),o.current.rotation.z=D.lerp(o.current.rotation.z,open?Math.sin(l/10)/4:0,.1),o.current.position.y=D.lerp(o.current.position.y,open?(-2+Math.sin(l))/3:-7,.6)}),n.useEffect(()=>()=>{},[]);const c=t.Scale,[y,w]=n.useState(window.innerWidth);n.useEffect(()=>{function P(){w(window.innerWidth)}return()=>{window.removeEventListener("resize",P)}},[]);const g=t.Hovered;return i.jsxs("group",{ref:o,...t,dispose:null,scale:y<=820?c:2,"rotation-x":19,children:[i.jsxs("group",{rotation:[-Math.PI,0,-3.135],children:[i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001.geometry,material:r["Black.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_1.geometry,material:r["Main.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_2.geometry,material:r["Second.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_3.geometry,material:r["KeysMain.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_4.geometry,material:r["KeysBottom.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_5.geometry,material:r["TopLine.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_6.geometry,material:r["DarkGrey.001"]})]}),i.jsxs("group",{rotation:[-Math.PI,0,-3.135],children:[i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001.geometry,material:r["Outline.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_1.geometry,children:i.jsx(Ve,{className:Ne.htmlMain,position:[0,1.23,-.005],transform:!0,occlude:!0,"rotation-y":91.1,"rotation-x":94.35,scale:.07,center:!0,style:{width:"96vw",height:"125vh"},children:i.jsx("div",{style:{height:"100%",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer"},onPointerDown:P=>P.stopPropagation(),children:(g==null?void 0:g.name)==="MAGENTO"&&i.jsx(Re,{})})})}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_2.geometry,material:r["Emission.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_3.geometry,material:r["Logo.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_4.geometry,material:r["Main.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_5.geometry,material:r["Text.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_6.geometry,material:r["Camera.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_7.geometry,material:r["Camera1.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_8.geometry,material:r["CameraGreen.001"]})]})]})}W.preload("./laptop.glb");export{Ke as default};
