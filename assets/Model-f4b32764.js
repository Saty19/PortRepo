import{a4 as n,a7 as Be,at as Ee,a8 as ae,k as L,au as Te,e as ke,af as ce,P as le,ac as Z,a5 as a,av as D}from"./index-6d687d6a.js";import{G as K,D as We,M as G}from"./index-9382078c.js";const T=new L,U=new L,Re=new L;function Oe(e,t,r){const o=T.setFromMatrixPosition(e.matrixWorld);o.project(t);const i=r.width/2,c=r.height/2;return[o.x*i+i,-(o.y*c)+c]}function $e(e,t){const r=T.setFromMatrixPosition(e.matrixWorld),o=U.setFromMatrixPosition(t.matrixWorld),i=r.sub(o),c=t.getWorldDirection(Re);return i.angleTo(c)>Math.PI/2}function ze(e,t,r,o){const i=T.setFromMatrixPosition(e.matrixWorld),c=i.clone();c.project(t),r.setFromCamera(c,t);const y=r.intersectObjects(o,!0);if(y.length){const w=y[0].distance;return i.distanceTo(r.ray.origin)<w}return!0}function De(e,t){if(t instanceof ce)return t.zoom;if(t instanceof le){const r=T.setFromMatrixPosition(e.matrixWorld),o=U.setFromMatrixPosition(t.matrixWorld),i=t.fov*Math.PI/180,c=r.distanceTo(o);return 1/(2*Math.tan(i/2)*c)}else return 1}function Fe(e,t,r){if(t instanceof le||t instanceof ce){const o=T.setFromMatrixPosition(e.matrixWorld),i=U.setFromMatrixPosition(t.matrixWorld),c=o.distanceTo(i),y=(r[1]-r[0])/(t.far-t.near),w=r[1]-y*t.far;return Math.round(y*c+w)}}const N=e=>Math.abs(e)<1e-10?0:e;function ue(e,t,r=""){let o="matrix3d(";for(let i=0;i!==16;i++)o+=N(t[i]*e.elements[i])+(i!==15?",":")");return r+o}const Le=(e=>t=>ue(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),He=(e=>(t,r)=>ue(t,e(r),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Ae(e){return e&&typeof e=="object"&&"current"in e}const Ie=n.forwardRef(({children:e,eps:t=.001,style:r,className:o,prepend:i,center:c,fullscreen:y,portal:w,distanceFactor:x,sprite:_=!1,transform:g=!1,occlude:l,onOcclude:q,castShadow:he,receiveShadow:fe,material:ye,geometry:J,zIndexRange:W=[16777271,0],calculatePosition:Q=Oe,as:xe="div",wrapperClass:H,pointerEvents:X="auto",...p},Y)=>{const{gl:ee,camera:u,scene:te,size:d,raycaster:ge,events:pe,viewport:ve}=Be(),[m]=n.useState(()=>document.createElement(xe)),A=n.useRef(),f=n.useRef(null),re=n.useRef(0),R=n.useRef([0,0]),B=n.useRef(null),I=n.useRef(null),j=(w==null?void 0:w.current)||pe.connected||ee.domElement.parentNode,P=n.useRef(null),O=n.useRef(!1),$=n.useMemo(()=>l&&l!=="blending"||Array.isArray(l)&&l.length&&Ae(l[0]),[l]);n.useLayoutEffect(()=>{const h=ee.domElement;l&&l==="blending"?(h.style.zIndex=`${Math.floor(W[0]/2)}`,h.style.position="absolute",h.style.pointerEvents="none"):(h.style.zIndex=null,h.style.position=null,h.style.pointerEvents=null)},[l]),n.useLayoutEffect(()=>{if(f.current){const h=A.current=Ee(m);if(te.updateMatrixWorld(),g)m.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const s=Q(f.current,u,d);m.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${s[0]}px,${s[1]}px,0);transform-origin:0 0;`}return j&&(i?j.prepend(m):j.appendChild(m)),()=>{j&&j.removeChild(m),h.unmount()}}},[j,g]),n.useLayoutEffect(()=>{H&&(m.className=H)},[H]);const oe=n.useMemo(()=>g?{position:"absolute",top:0,left:0,width:d.width,height:d.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:c?"translate3d(-50%,-50%,0)":"none",...y&&{top:-d.height/2,left:-d.width/2,width:d.width,height:d.height},...r},[r,c,y,d,g]),we=n.useMemo(()=>({position:"absolute",pointerEvents:X}),[X]);n.useLayoutEffect(()=>{if(O.current=!1,g){var h;(h=A.current)==null||h.render(n.createElement("div",{ref:B,style:oe},n.createElement("div",{ref:I,style:we},n.createElement("div",{ref:Y,className:o,style:r,children:e}))))}else{var s;(s=A.current)==null||s.render(n.createElement("div",{ref:Y,style:oe,className:o,children:e}))}});const C=n.useRef(!0);ae(h=>{if(f.current){u.updateMatrixWorld(),f.current.updateWorldMatrix(!0,!1);const s=g?R.current:Q(f.current,u,d);if(g||Math.abs(re.current-u.zoom)>t||Math.abs(R.current[0]-s[0])>t||Math.abs(R.current[1]-s[1])>t){const M=$e(f.current,u);let v=!1;$&&(Array.isArray(l)?v=l.map(S=>S.current):l!=="blending"&&(v=[te]));const E=C.current;if(v){const S=ze(f.current,u,ge,v);C.current=S&&!M}else C.current=!M;E!==C.current&&(q?q(!C.current):m.style.display=C.current?"block":"none");const z=Math.floor(W[0]/2),Pe=l?$?[W[0],z]:[z-1,0]:W;if(m.style.zIndex=`${Fe(f.current,u,Pe)}`,g){const[S,se]=[d.width/2,d.height/2],V=u.projectionMatrix.elements[5]*se,{isOrthographicCamera:ie,top:Me,left:Se,bottom:be,right:_e}=u,je=Le(u.matrixWorldInverse),Ce=ie?`scale(${V})translate(${N(-(_e+Se)/2)}px,${N((Me+be)/2)}px)`:`translateZ(${V}px)`;let b=f.current.matrixWorld;_&&(b=u.matrixWorldInverse.clone().transpose().copyPosition(b).scale(f.current.scale),b.elements[3]=b.elements[7]=b.elements[11]=0,b.elements[15]=1),m.style.width=d.width+"px",m.style.height=d.height+"px",m.style.perspective=ie?"":`${V}px`,B.current&&I.current&&(B.current.style.transform=`${Ce}${je}translate(${S}px,${se}px)`,I.current.style.transform=He(b,1/((x||10)/400)))}else{const S=x===void 0?1:De(f.current,u)*x;m.style.transform=`translate3d(${s[0]}px,${s[1]}px,0) scale(${S})`}R.current=s,re.current=u.zoom}}if(!$&&P.current&&!O.current)if(g){if(B.current){const s=B.current.children[0];if(s!=null&&s.clientWidth&&s!=null&&s.clientHeight){const{isOrthographicCamera:M}=u;if(M||J)p.scale&&(Array.isArray(p.scale)?p.scale instanceof L?P.current.scale.copy(p.scale.clone().divideScalar(1)):P.current.scale.set(1/p.scale[0],1/p.scale[1],1/p.scale[2]):P.current.scale.setScalar(1/p.scale));else{const v=(x||10)/400,E=s.clientWidth*v,z=s.clientHeight*v;P.current.scale.set(E,z,1)}O.current=!0}}}else{const s=m.children[0];if(s!=null&&s.clientWidth&&s!=null&&s.clientHeight){const M=1/ve.factor,v=s.clientWidth*M,E=s.clientHeight*M;P.current.scale.set(v,E,1),O.current=!0}P.current.lookAt(h.camera.position)}});const ne=n.useMemo(()=>({vertexShader:g?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[g]);return n.createElement("group",Te({},p,{ref:f}),l&&!$&&n.createElement("mesh",{castShadow:he,receiveShadow:fe,ref:P},J||n.createElement("planeGeometry",null),ye||n.createElement("shaderMaterial",{side:ke,vertexShader:ne.vertexShader,fragmentShader:ne.fragmentShader})))});let F=null,me="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function de(e,t,r){return o=>{r&&r(o),e&&(F||(F=new We),F.setDecoderPath(typeof e=="string"?e:me),o.setDRACOLoader(F)),t&&o.setMeshoptDecoder(typeof G=="function"?G():G)}}function k(e,t=!0,r=!0,o){return Z(K,e,de(t,r,o))}k.preload=(e,t=!0,r=!0,o)=>Z.preload(K,e,de(t,r,o));k.clear=e=>Z.clear(K,e);k.setDecoderPath=e=>{me=e};const Ve="_htmlMain_1cezf_1",Ge={htmlMain:Ve};function Ke(e){const{nodes:t,materials:r}=k("./laptop.glb"),o=n.useRef();ae(x=>{const _=x.clock.getElapsedTime();o.current.rotation.x=D.lerp(o.current.rotation.x,open?Math.cos(_/10)/7+.25:0,.1),o.current.rotation.y=D.lerp(o.current.rotation.y,open?Math.sin(_/10)/2:0,.1),o.current.rotation.z=D.lerp(o.current.rotation.z,open?Math.sin(_/10)/4:0,.1),o.current.position.y=D.lerp(o.current.position.y,open?(-2+Math.sin(_))/3:-7,.6)}),n.useEffect(()=>()=>{},[]);const c=e.Scale,[y,w]=n.useState(window.innerWidth);return n.useEffect(()=>{function x(){w(window.innerWidth)}return()=>{window.removeEventListener("resize",x)}},[]),e==null||e.Hovered,a.jsxs("group",{ref:o,...e,dispose:null,scale:y<=820?c:3.2,"rotation-x":19,position:[0,-10,0],children:[a.jsxs("group",{rotation:[-Math.PI,0,-3.135],children:[a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_BottomPart_Cube001.geometry,material:r["Black.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_BottomPart_Cube001_1.geometry,material:r["Main.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_BottomPart_Cube001_2.geometry,material:r["Second.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_BottomPart_Cube001_3.geometry,material:r["KeysMain.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_BottomPart_Cube001_4.geometry,material:r["KeysBottom.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_BottomPart_Cube001_5.geometry,material:r["TopLine.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_BottomPart_Cube001_6.geometry,material:r["DarkGrey.001"]})]}),a.jsxs("group",{rotation:[-Math.PI,0,-3.135],children:[a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_TopPart_Cube001.geometry,material:r["Outline.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_TopPart_Cube001_1.geometry,children:a.jsx(Ie,{className:Ge.htmlMain,position:[-.05,1.35,-.001],transform:!0,occlude:!0,"rotation-y":91.11,"rotation-x":94.33,scale:[.07,.088,.07],center:!0,style:{width:"96vw",height:"125vh"},children:a.jsx("div",{style:{height:"100%",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer"},onPointerDown:x=>x.stopPropagation()})})}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_TopPart_Cube001_2.geometry,material:r["Emission.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_TopPart_Cube001_3.geometry,material:r["Logo.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_TopPart_Cube001_4.geometry,material:r["Main.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_TopPart_Cube001_5.geometry,material:r["Text.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_TopPart_Cube001_6.geometry,material:r["Camera.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_TopPart_Cube001_7.geometry,material:r["Camera1.001"]}),a.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:t.macBook_TopPart_Cube001_8.geometry,material:r["CameraGreen.001"]})]})]})}k.preload("./laptop.glb");export{Ke as default};
