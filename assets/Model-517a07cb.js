import{r as o,u as Se,c as Ee,a as ie,_ as Ce,D as We,V as _,O as se,P as ae,j as s,b as ce,M as F}from"./index-aea0d8a9.js";const T=new _,G=new _,Re=new _;function Te(e,t,n){const r=T.setFromMatrixPosition(e.matrixWorld);r.project(t);const a=n.width/2,c=n.height/2;return[r.x*a+a,-(r.y*c)+c]}function Ae(e,t){const n=T.setFromMatrixPosition(e.matrixWorld),r=G.setFromMatrixPosition(t.matrixWorld),a=n.sub(r),c=t.getWorldDirection(Re);return a.angleTo(c)>Math.PI/2}function Oe(e,t,n,r){const a=T.setFromMatrixPosition(e.matrixWorld),c=a.clone();c.project(t),n.setFromCamera(c,t);const g=n.intersectObjects(r,!0);if(g.length){const b=g[0].distance;return a.distanceTo(n.ray.origin)<b}return!0}function $e(e,t){if(t instanceof se)return t.zoom;if(t instanceof ae){const n=T.setFromMatrixPosition(e.matrixWorld),r=G.setFromMatrixPosition(t.matrixWorld),a=t.fov*Math.PI/180,c=n.distanceTo(r);return 1/(2*Math.tan(a/2)*c)}else return 1}function ze(e,t,n){if(t instanceof ae||t instanceof se){const r=T.setFromMatrixPosition(e.matrixWorld),a=G.setFromMatrixPosition(t.matrixWorld),c=r.distanceTo(a),g=(n[1]-n[0])/(t.far-t.near),b=n[1]-g*t.far;return Math.round(g*c+b)}}const I=e=>Math.abs(e)<1e-10?0:e;function le(e,t,n=""){let r="matrix3d(";for(let a=0;a!==16;a++)r+=I(t[a]*e.elements[a])+(a!==15?",":")");return n+r}const ke=(e=>t=>le(t,e))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),Fe=(e=>(t,n)=>le(t,e(n),"translate(-50%,-50%)"))(e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1]);function Le(e){return e&&typeof e=="object"&&"current"in e}const _e=o.forwardRef(({children:e,eps:t=.001,style:n,className:r,prepend:a,center:c,fullscreen:g,portal:b,distanceFactor:x,sprite:P=!1,transform:l=!1,occlude:u,onOcclude:q,castShadow:ue,receiveShadow:de,material:me,geometry:B,zIndexRange:A=[16777271,0],calculatePosition:U=Te,as:he="div",wrapperClass:H,pointerEvents:Z="auto",...y},J)=>{const{gl:K,camera:d,scene:Q,size:h,raycaster:fe,events:xe,viewport:pe}=Se(),[m]=o.useState(()=>document.createElement(he)),N=o.useRef(),p=o.useRef(null),X=o.useRef(0),O=o.useRef([0,0]),W=o.useRef(null),V=o.useRef(null),E=(b==null?void 0:b.current)||xe.connected||K.domElement.parentNode,M=o.useRef(null),$=o.useRef(!1),z=o.useMemo(()=>u&&u!=="blending"||Array.isArray(u)&&u.length&&Le(u[0]),[u]);o.useLayoutEffect(()=>{const f=K.domElement;u&&u==="blending"?(f.style.zIndex=`${Math.floor(A[0]/2)}`,f.style.position="absolute",f.style.pointerEvents="none"):(f.style.zIndex=null,f.style.position=null,f.style.pointerEvents=null)},[u]),o.useLayoutEffect(()=>{if(p.current){const f=N.current=Ee(m);if(Q.updateMatrixWorld(),l)m.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const i=U(p.current,d,h);m.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${i[0]}px,${i[1]}px,0);transform-origin:0 0;`}return E&&(a?E.prepend(m):E.appendChild(m)),()=>{E&&E.removeChild(m),f.unmount()}}},[E,l]),o.useLayoutEffect(()=>{H&&(m.className=H)},[H]);const Y=o.useMemo(()=>l?{position:"absolute",top:0,left:0,width:h.width,height:h.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:c?"translate3d(-50%,-50%,0)":"none",...g&&{top:-h.height/2,left:-h.width/2,width:h.width,height:h.height},...n},[n,c,g,h,l]),ge=o.useMemo(()=>({position:"absolute",pointerEvents:Z}),[Z]);o.useLayoutEffect(()=>{if($.current=!1,l){var f;(f=N.current)==null||f.render(o.createElement("div",{ref:W,style:Y},o.createElement("div",{ref:V,style:ge},o.createElement("div",{ref:J,className:r,style:n,children:e}))))}else{var i;(i=N.current)==null||i.render(o.createElement("div",{ref:J,style:Y,className:r,children:e}))}});const C=o.useRef(!0);ie(f=>{if(p.current){d.updateMatrixWorld(),p.current.updateWorldMatrix(!0,!1);const i=l?O.current:U(p.current,d,h);if(l||Math.abs(X.current-d.zoom)>t||Math.abs(O.current[0]-i[0])>t||Math.abs(O.current[1]-i[1])>t){const j=Ae(p.current,d);let v=!1;z&&(Array.isArray(u)?v=u.map(w=>w.current):u!=="blending"&&(v=[Q]));const R=C.current;if(v){const w=Oe(p.current,d,fe,v);C.current=w&&!j}else C.current=!j;R!==C.current&&(q?q(!C.current):m.style.display=C.current?"block":"none");const k=Math.floor(A[0]/2),ye=u?z?[A[0],k]:[k-1,0]:A;if(m.style.zIndex=`${ze(p.current,d,ye)}`,l){const[w,te]=[h.width/2,h.height/2],D=d.projectionMatrix.elements[5]*te,{isOrthographicCamera:ne,top:ve,left:be,bottom:Me,right:Pe}=d,je=ke(d.matrixWorldInverse),we=ne?`scale(${D})translate(${I(-(Pe+be)/2)}px,${I((ve+Me)/2)}px)`:`translateZ(${D}px)`;let S=p.current.matrixWorld;P&&(S=d.matrixWorldInverse.clone().transpose().copyPosition(S).scale(p.current.scale),S.elements[3]=S.elements[7]=S.elements[11]=0,S.elements[15]=1),m.style.width=h.width+"px",m.style.height=h.height+"px",m.style.perspective=ne?"":`${D}px`,W.current&&V.current&&(W.current.style.transform=`${we}${je}translate(${w}px,${te}px)`,V.current.style.transform=Fe(S,1/((x||10)/400)))}else{const w=x===void 0?1:$e(p.current,d)*x;m.style.transform=`translate3d(${i[0]}px,${i[1]}px,0) scale(${w})`}O.current=i,X.current=d.zoom}}if(!z&&M.current&&!$.current)if(l){if(W.current){const i=W.current.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const{isOrthographicCamera:j}=d;if(j||B)y.scale&&(Array.isArray(y.scale)?y.scale instanceof _?M.current.scale.copy(y.scale.clone().divideScalar(1)):M.current.scale.set(1/y.scale[0],1/y.scale[1],1/y.scale[2]):M.current.scale.setScalar(1/y.scale));else{const v=(x||10)/400,R=i.clientWidth*v,k=i.clientHeight*v;M.current.scale.set(R,k,1)}$.current=!0}}}else{const i=m.children[0];if(i!=null&&i.clientWidth&&i!=null&&i.clientHeight){const j=1/pe.factor,v=i.clientWidth*j,R=i.clientHeight*j;M.current.scale.set(v,R,1),$.current=!0}M.current.lookAt(f.camera.position)}});const ee=o.useMemo(()=>({vertexShader:l?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[l]);return o.createElement("group",Ce({},y,{ref:p}),u&&!z&&o.createElement("mesh",{castShadow:ue,receiveShadow:de,ref:M},B||o.createElement("planeGeometry",null),me||o.createElement("shaderMaterial",{side:We,vertexShader:ee.vertexShader,fragmentShader:ee.fragmentShader})))}),He="_content_15sjy_2",Ne="_wrapper_15sjy_10",oe={content:He,wrapper:Ne},L=()=>{const e={height:"100px",backgroundColor:"#f0f0f0",padding:"20px",textAlign:"center"},t={maxWidth:"100%",maxHeight:"400px",margin:"20px 0",borderRadius:"8px"};return s.jsxs("div",{style:e,children:[s.jsx("h1",{children:"Tall Component"}),s.jsx("img",{src:"https://via.placeholder.com/800x400",alt:"Placeholder Image",style:t}),s.jsx("p",{style:{color:"black"},children:"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."})]})},Ve=()=>{const e={width:"668px",height:"432px",padding:"10px",transform:"scale(0.5)",transformOrigin:"top left",backgroundColor:"#121212",boxShadow:"0 0 10px rgba(0, 0, 0, 0.1)",textAlign:"center"},t={color:"#333",fontSize:"24px",marginBottom:"15px"},n={color:"#666",fontSize:"16px"};return s.jsxs("div",{style:e,children:[s.jsx("h2",{style:t,children:"Simple Component"}),s.jsx("p",{style:n,children:"This is a simple React component with inline styles."})]})},re=Ve;function Ie(e){const{nodes:t,materials:n}=ce("./mac-draco.glb"),r=o.useRef();ie(P=>{const l=P.clock.getElapsedTime();r.current.rotation.x=F.lerp(r.current.rotation.x,open?Math.cos(l/10)/8+.35:0,.1),r.current.rotation.y=F.lerp(r.current.rotation.y,open?Math.sin(l/10)/2:0,.1),r.current.rotation.z=F.lerp(r.current.rotation.z,open?Math.sin(l/10)/4:0,.1),r.current.position.y=F.lerp(r.current.position.y,open?(-2+Math.sin(l))/5:-7,.6)}),o.useLayoutEffect(()=>()=>{},[]);const c={MAGENTO:L,REACT:re,ANGULAR:L,PHP:L,LARAVEL:L};e.Scale;const[g,b]=o.useState(window.innerWidth);o.useLayoutEffect(()=>{function P(){b(window.innerWidth)}return()=>{window.removeEventListener("resize",P)}},[]);const x=e==null?void 0:e.Hovered;return c[x==null?void 0:x.name],s.jsxs("group",{ref:r,...e,dispose:null,children:[s.jsx("group",{"rotation-x":-.425,position:[0,-.04,.41],children:s.jsxs("group",{position:[0,2.96,-.13],rotation:[Math.PI/2,0,0],children:[s.jsx("mesh",{material:n.aluminium,geometry:t.Cube008.geometry}),s.jsx("mesh",{material:n["matte.001"],geometry:t.Cube008_1.geometry}),s.jsx("mesh",{geometry:t.Cube008_2.geometry,children:s.jsx(_e,{className:oe.content,s:!0,"rotation-x":-Math.PI/2,position:[.4,.25,-.01],transform:!0,occlude:!0,children:s.jsx("div",{className:oe.wrapper,onPointerDown:P=>P.stopPropagation(),children:(x==null?void 0:x.name)=="MAGENTO"&&s.jsx(re,{})})})})]})}),s.jsx("mesh",{material:n.keys,geometry:t.keyboard.geometry,position:[1.79,0,3.45]}),s.jsxs("group",{position:[0,-.1,3.39],children:[s.jsx("mesh",{material:n.aluminium,geometry:t.Cube002.geometry}),s.jsx("mesh",{material:n.trackpad,geometry:t.Cube002_1.geometry})]}),s.jsx("mesh",{material:n.touchbar,geometry:t.touchbar.geometry,position:[0,-.03,1.2]})]})}ce.preload("./mac-draco.glb");export{Ie as default};
