import{a4 as n,a7 as Be,au as Ee,a9 as N,k as A,av as Te,e as ke,ah as ce,P as le,ad as K,aw as U,ax as We,ay as G,a5 as i,az as Re,aA as F}from"./index-3791107c.js";const T=new A,q=new A,Oe=new A;function ze(t,e,r){const o=T.setFromMatrixPosition(t.matrixWorld);o.project(e);const a=r.width/2,c=r.height/2;return[o.x*a+a,-(o.y*c)+c]}function $e(t,e){const r=T.setFromMatrixPosition(t.matrixWorld),o=q.setFromMatrixPosition(e.matrixWorld),a=r.sub(o),c=e.getWorldDirection(Oe);return a.angleTo(c)>Math.PI/2}function Fe(t,e,r,o){const a=T.setFromMatrixPosition(t.matrixWorld),c=a.clone();c.project(e),r.setFromCamera(c,e);const y=r.intersectObjects(o,!0);if(y.length){const w=y[0].distance;return a.distanceTo(r.ray.origin)<w}return!0}function Le(t,e){if(e instanceof ce)return e.zoom;if(e instanceof le){const r=T.setFromMatrixPosition(t.matrixWorld),o=q.setFromMatrixPosition(e.matrixWorld),a=e.fov*Math.PI/180,c=r.distanceTo(o);return 1/(2*Math.tan(a/2)*c)}else return 1}function Ae(t,e,r){if(e instanceof le||e instanceof ce){const o=T.setFromMatrixPosition(t.matrixWorld),a=q.setFromMatrixPosition(e.matrixWorld),c=o.distanceTo(a),y=(r[1]-r[0])/(e.far-e.near),w=r[1]-y*e.far;return Math.round(y*c+w)}}const Z=t=>Math.abs(t)<1e-10?0:t;function ue(t,e,r=""){let o="matrix3d(";for(let a=0;a!==16;a++)o+=Z(e[a]*t.elements[a])+(a!==15?",":")");return r+o}const De=(t=>e=>ue(e,t))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),He=(t=>(e,r)=>ue(e,t(r),"translate(-50%,-50%)"))(t=>[1/t,1/t,1/t,1,-1/t,-1/t,-1/t,-1,1/t,1/t,1/t,1,1,1,1,1]);function Ie(t){return t&&typeof t=="object"&&"current"in t}const Ve=n.forwardRef(({children:t,eps:e=.001,style:r,className:o,prepend:a,center:c,fullscreen:y,portal:w,distanceFactor:g,sprite:M=!1,transform:l=!1,occlude:u,onOcclude:J,castShadow:he,receiveShadow:fe,material:xe,geometry:Q,zIndexRange:W=[16777271,0],calculatePosition:X=ze,as:ye="div",wrapperClass:D,pointerEvents:Y="auto",...p},ee)=>{const{gl:te,camera:m,scene:re,size:h,raycaster:ge,events:pe,viewport:ve}=Be(),[d]=n.useState(()=>document.createElement(ye)),H=n.useRef(),x=n.useRef(null),oe=n.useRef(0),R=n.useRef([0,0]),B=n.useRef(null),I=n.useRef(null),j=(w==null?void 0:w.current)||pe.connected||te.domElement.parentNode,P=n.useRef(null),O=n.useRef(!1),z=n.useMemo(()=>u&&u!=="blending"||Array.isArray(u)&&u.length&&Ie(u[0]),[u]);n.useLayoutEffect(()=>{const f=te.domElement;u&&u==="blending"?(f.style.zIndex=`${Math.floor(W[0]/2)}`,f.style.position="absolute",f.style.pointerEvents="none"):(f.style.zIndex=null,f.style.position=null,f.style.pointerEvents=null)},[u]),n.useLayoutEffect(()=>{if(x.current){const f=H.current=Ee(d);if(re.updateMatrixWorld(),l)d.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const s=X(x.current,m,h);d.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${s[0]}px,${s[1]}px,0);transform-origin:0 0;`}return j&&(a?j.prepend(d):j.appendChild(d)),()=>{j&&j.removeChild(d),f.unmount()}}},[j,l]),n.useLayoutEffect(()=>{D&&(d.className=D)},[D]);const ne=n.useMemo(()=>l?{position:"absolute",top:0,left:0,width:h.width,height:h.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:c?"translate3d(-50%,-50%,0)":"none",...y&&{top:-h.height/2,left:-h.width/2,width:h.width,height:h.height},...r},[r,c,y,h,l]),we=n.useMemo(()=>({position:"absolute",pointerEvents:Y}),[Y]);n.useLayoutEffect(()=>{if(O.current=!1,l){var f;(f=H.current)==null||f.render(n.createElement("div",{ref:B,style:ne},n.createElement("div",{ref:I,style:we},n.createElement("div",{ref:ee,className:o,style:r,children:t}))))}else{var s;(s=H.current)==null||s.render(n.createElement("div",{ref:ee,style:ne,className:o,children:t}))}});const C=n.useRef(!0);N(f=>{if(x.current){m.updateMatrixWorld(),x.current.updateWorldMatrix(!0,!1);const s=l?R.current:X(x.current,m,h);if(l||Math.abs(oe.current-m.zoom)>e||Math.abs(R.current[0]-s[0])>e||Math.abs(R.current[1]-s[1])>e){const S=$e(x.current,m);let v=!1;z&&(Array.isArray(u)?v=u.map(b=>b.current):u!=="blending"&&(v=[re]));const E=C.current;if(v){const b=Fe(x.current,m,ge,v);C.current=b&&!S}else C.current=!S;E!==C.current&&(J?J(!C.current):d.style.display=C.current?"block":"none");const $=Math.floor(W[0]/2),Pe=u?z?[W[0],$]:[$-1,0]:W;if(d.style.zIndex=`${Ae(x.current,m,Pe)}`,l){const[b,ae]=[h.width/2,h.height/2],V=m.projectionMatrix.elements[5]*ae,{isOrthographicCamera:ie,top:Me,left:Se,bottom:be,right:_e}=m,je=De(m.matrixWorldInverse),Ce=ie?`scale(${V})translate(${Z(-(_e+Se)/2)}px,${Z((Me+be)/2)}px)`:`translateZ(${V}px)`;let _=x.current.matrixWorld;M&&(_=m.matrixWorldInverse.clone().transpose().copyPosition(_).scale(x.current.scale),_.elements[3]=_.elements[7]=_.elements[11]=0,_.elements[15]=1),d.style.width=h.width+"px",d.style.height=h.height+"px",d.style.perspective=ie?"":`${V}px`,B.current&&I.current&&(B.current.style.transform=`${Ce}${je}translate(${b}px,${ae}px)`,I.current.style.transform=He(_,1/((g||10)/400)))}else{const b=g===void 0?1:Le(x.current,m)*g;d.style.transform=`translate3d(${s[0]}px,${s[1]}px,0) scale(${b})`}R.current=s,oe.current=m.zoom}}if(!z&&P.current&&!O.current)if(l){if(B.current){const s=B.current.children[0];if(s!=null&&s.clientWidth&&s!=null&&s.clientHeight){const{isOrthographicCamera:S}=m;if(S||Q)p.scale&&(Array.isArray(p.scale)?p.scale instanceof A?P.current.scale.copy(p.scale.clone().divideScalar(1)):P.current.scale.set(1/p.scale[0],1/p.scale[1],1/p.scale[2]):P.current.scale.setScalar(1/p.scale));else{const v=(g||10)/400,E=s.clientWidth*v,$=s.clientHeight*v;P.current.scale.set(E,$,1)}O.current=!0}}}else{const s=d.children[0];if(s!=null&&s.clientWidth&&s!=null&&s.clientHeight){const S=1/ve.factor,v=s.clientWidth*S,E=s.clientHeight*S;P.current.scale.set(v,E,1),O.current=!0}P.current.lookAt(f.camera.position)}});const se=n.useMemo(()=>({vertexShader:l?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[l]);return n.createElement("group",Te({},p,{ref:x}),u&&!z&&n.createElement("mesh",{castShadow:he,receiveShadow:fe,ref:P},Q||n.createElement("planeGeometry",null),xe||n.createElement("shaderMaterial",{side:ke,vertexShader:se.vertexShader,fragmentShader:se.fragmentShader})))});let L=null,me="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function de(t,e,r){return o=>{r&&r(o),t&&(L||(L=new We),L.setDecoderPath(typeof t=="string"?t:me),o.setDRACOLoader(L)),e&&o.setMeshoptDecoder(typeof G=="function"?G():G)}}function k(t,e=!0,r=!0,o){return K(U,t,de(e,r,o))}k.preload=(t,e=!0,r=!0,o)=>K.preload(U,t,de(e,r,o));k.clear=t=>K.clear(U,t);k.setDecoderPath=t=>{me=t};const Ge="_htmlMain_1cezf_1",Ne={htmlMain:Ge};function Ke(t){const{nodes:e,materials:r}=k("/laptop.glb"),o=n.useRef(),a=M=>{const l=M.clock.getElapsedTime();o.current.rotation.x=F.lerp(o.current.rotation.x,open?Math.cos(l/10)/7+.25:0,.1),o.current.rotation.y=F.lerp(o.current.rotation.y,open?Math.sin(l/10)/2:0,.1),o.current.rotation.z=F.lerp(o.current.rotation.z,open?Math.sin(l/10)/4:0,.1),o.current.position.y=F.lerp(o.current.position.y,open?(-2+Math.sin(l))/3:-7,.6)};N(a),n.useEffect(()=>()=>{N.unsubscribe(a)},[]);const c=t.Scale,[y,w]=n.useState(window.innerWidth);n.useEffect(()=>{function M(){w(window.innerWidth)}return()=>{window.removeEventListener("resize",M)}},[]);const g=t.Hovered;return i.jsxs("group",{ref:o,...t,dispose:null,scale:y<=820?c:2,"rotation-x":19,children:[i.jsxs("group",{rotation:[-Math.PI,0,-3.135],children:[i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001.geometry,material:r["Black.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_1.geometry,material:r["Main.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_2.geometry,material:r["Second.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_3.geometry,material:r["KeysMain.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_4.geometry,material:r["KeysBottom.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_5.geometry,material:r["TopLine.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_BottomPart_Cube001_6.geometry,material:r["DarkGrey.001"]})]}),i.jsxs("group",{rotation:[-Math.PI,0,-3.135],children:[i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001.geometry,material:r["Outline.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_1.geometry,children:i.jsx(Ve,{className:Ne.htmlMain,position:[0,1.23,-.005],transform:!0,occlude:!0,"rotation-y":91.1,"rotation-x":94.35,scale:.07,center:!0,style:{width:"96vw",height:"125vh"},children:i.jsx("div",{style:{height:"100%",display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer"},onPointerDown:M=>M.stopPropagation(),children:(g==null?void 0:g.name)==="MAGENTO"&&i.jsx(Re,{})})})}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_2.geometry,material:r["Emission.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_3.geometry,material:r["Logo.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_4.geometry,material:r["Main.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_5.geometry,material:r["Text.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_6.geometry,material:r["Camera.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_7.geometry,material:r["Camera1.001"]}),i.jsx("mesh",{castShadow:!0,receiveShadow:!0,geometry:e.macBook_TopPart_Cube001_8.geometry,material:r["CameraGreen.001"]})]})]})}k.preload("/laptop.glb");export{Ke as default};
